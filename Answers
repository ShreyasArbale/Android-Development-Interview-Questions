## Android Platform & Architecture

1.  **What is Android and explain its open-source nature?**
    Android is an open-source, Linux-based operating system primarily designed for mobile devices like smartphones and tablets. Developed by Google and the Open Handset Alliance, its open-source nature means its source code is freely available to the public. This allows device manufacturers to customize it for their hardware and developers to build applications without licensing fees, fostering a diverse ecosystem, rapid innovation, and widespread adoption.

2.  **List all major Android versions and their key features.**

      * **Lollipop (5.0):** Introduced Material Design, ART as the default runtime, and revamped notifications.
      * **Marshmallow (6.0):** Brought runtime permissions, Doze mode for battery optimization, and fingerprint API support.
      * **Nougat (7.0):** Added multi-window support, improved notifications with direct reply, and Data Saver.
      * **Oreo (8.0):** Introduced notification channels, Picture-in-Picture (PiP) mode, and autofill framework.
      * **Pie (9):** Featured gesture navigation, Adaptive Battery, App Actions, and Slices.
      * **Android 10:** Focused on privacy controls, introduced a system-wide dark theme, and enhanced gesture navigation.
      * **Android 11:** Improved conversation notifications, chat bubbles, and one-time permissions.
      * **Android 12:** Launched with Material You design language, redesigned widgets, and a Privacy Dashboard.
      * **Android 13:** Introduced themed app icons, per-app language preferences, and a new photo picker.
      * **Android 14:** Further refined predictive back gestures, offered more customizable lock screen options, and enhanced health connectivity features.

3.  **What are the main layers of Android architecture?**
    The Android architecture is typically described in five main layers, from bottom to top:

      * **Linux Kernel:** The foundation, providing core system services like security, memory management, process management, and drivers.
      * **Hardware Abstraction Layer (HAL):** An interface layer that standardizes how Android interacts with various hardware components, allowing Android to be hardware-agnostic.
      * **Android Runtime (ART) & Native Libraries:** ART executes Android applications. Native libraries (like OpenGL ES, SQLite) provide essential functionalities for the system and apps.
      * **Java API Framework:** The set of high-level Java/Kotlin APIs that developers use to build Android applications (e.g., Activity Manager, View System, Notification Manager).
      * **Applications:** The top layer, including both pre-installed system applications (e.g., Phone, Contacts) and user-installed third-party applications.

4.  **Explain Android Runtime (ART) and its role in Android development.**
    Android Runtime (ART) is the managed runtime that executes Android applications, replacing Dalvik from Android 5.0 (Lollipop) onwards. Its primary role in development is to compile the app's DEX bytecode into native machine code using Ahead-Of-Time (AOT) compilation during installation. This results in significant improvements in app startup time, overall runtime performance, and battery efficiency, leading to a smoother user experience. It also offers enhanced debugging capabilities.

5.  **What are the differences between Dalvik and ART?**
    The main differences lie in their compilation strategies:

      * **Dalvik:** Used Just-In-Time (JIT) compilation. App bytecode was compiled into machine code on-the-fly during app execution. This led to faster app installation but slower app startup and generally lower runtime performance due to continuous compilation.
      * **ART:** Primarily uses Ahead-Of-Time (AOT) compilation. App bytecode is compiled into native machine code during app installation. This results in slower installation and larger app sizes (due to stored native code) but provides much faster app startup times and significantly smoother runtime performance. ART also features a more efficient garbage collector.

6.  **Explain JIT (Just-In-Time) and AOT (Ahead-Of-Time) compilation in Android.**

      * **JIT (Just-In-Time) Compilation:** In this model (primarily used by Dalvik), the app's bytecode is compiled into native machine code at runtime, just before a method or code block is executed. Once compiled, the native code can be cached for future use.
      * **AOT (Ahead-Of-Time) Compilation:** In this model (primarily used by ART), the entire app's bytecode is compiled into native machine code *before* the app is launched, typically during its installation. This pre-compiled native code is then directly executed, leading to better performance and battery efficiency at runtime. ART often employs a hybrid approach, using JIT for dynamic code or if AOT compilation is not feasible.

7.  **What is an APK file and what components does it contain?**
    An APK (Android Package Kit) file is the package file format used by the Android operating system for the distribution and installation of mobile applications. It's essentially a compressed archive, similar to a .zip file, containing all the elements an Android app needs to install and run correctly.
    Key components typically include:

      * `AndroidManifest.xml`: Declares the app's components, permissions, and features.
      * `classes.dex`: Contains the compiled Java/Kotlin code (DEX bytecode).
      * `resources.arsc`: Compiled binary resources (strings, colors, styles, etc.).
      * `res/`: Raw, uncompiled resources like images, layouts, and XML files.
      * `assets/`: Raw asset files copied directly into the app's file system.
      * `lib/`: Compiled native libraries (.so files) for different CPU architectures.
      * `META-INF/`: Contains signature and manifest information for integrity verification.

8.  **Describe the Android build process and its main stages.**
    The Android build process transforms your source code and resources into a deployable APK file. The main stages are:

    1.  **Resource Compilation (aapt2):** The Android Asset Packaging Tool (aapt2) compiles your app's resources (`res/`) and `AndroidManifest.xml`, generating resource IDs and the `R.java` (or `R.kt`) file.
    2.  **Java/Kotlin Compilation:** Your `.java` or `.kt` source code files are compiled into Java bytecode (`.class` files) by `javac` or `kotlinc`.
    3.  **DEX Conversion (D8/R8):** The Java bytecode (`.class` files) is converted into Dalvik Executable (DEX) bytecode (`.dex` files) by the D8 compiler (or R8 for more advanced shrinking/obfuscation). DEX files are optimized for the Android Runtime.
    4.  **APK Packaging:** All the compiled assets (`.dex` files, compiled resources, native libraries, `AndroidManifest.xml`, etc.) are packaged into a single `.apk` archive.
    5.  **Signing:** The APK is digitally signed with a certificate (debug for development, release for production) to verify its authenticity and ensure it hasn't been tampered with.
    6.  **Zipalign (for release builds):** This optional but highly recommended step optimizes the APK by aligning uncompressed data, allowing efficient memory mapping at runtime and reducing RAM consumption.

9.  **What is a DEX file and its significance in Android?**
    A DEX (Dalvik Executable) file is the executable file format that contains the compiled bytecode of an Android application. This bytecode is what the Android Runtime (ART) or Dalvik Virtual Machine (for older Android versions) executes. Its significance lies in:

      * **Execution Core:** It's the central binary component; without it, an Android app cannot run.
      * **Optimization for Mobile:** DEX files are optimized for efficiency and compactness, crucial for devices with limited resources.
      * **Interoperability:** It allows Java/Kotlin code to run on the Android platform regardless of the underlying device hardware, as long as a compatible runtime exists.
      * **Multidex:** Supports applications with a large number of methods by allowing multiple DEX files.

10. **What languages are primarily used for Android development?**
    The two primary languages for Android development are:

      * **Kotlin:** Google's preferred modern language for Android development. It's concise, null-safe, offers coroutines for asynchronous programming, and is fully interoperable with Java.
      * **Java:** The traditional and widely used language for Android development. It's an object-oriented language that forms the foundation of the Android framework.
        Additionally, **C/C++** can be used via the Android Native Development Kit (NDK) for performance-critical components.

11. **What is the AndroidManifest.xml file and its purpose?**
    The `AndroidManifest.xml` file is a fundamental XML file located at the root of every Android application project. It acts as a descriptor for the Android system, providing essential information about the application, its components, and its requirements.
    Its purpose is to declare:

      * All application components (Activities, Services, Broadcast Receivers, Content Providers).
      * Permissions the app requires to access system resources or other app data (e.g., internet, camera).
      * Hardware and software features the app needs (e.g., camera, OpenGL ES version).
      * The minimum and target API levels.
      * Application metadata like its icon, label, and theme.
      * Intent Filters, which specify what types of Intents a component can respond to, making them discoverable.

12. **What is the Android Native Development Kit (NDK) and when would you use it?**
    The Android Native Development Kit (NDK) is a toolset that allows Android developers to implement parts of their application using native-code languages like C and C++. These native components are compiled into shared libraries (`.so` files) that can be included in the APK.
    You would use the NDK in specific scenarios where native code offers significant advantages:

      * **Performance-Critical Tasks:** For computationally intensive operations like complex algorithms, game engines, physics simulations, or advanced audio/video processing.
      * **Reusing Existing Native Code:** If you have an existing C/C++ codebase or a third-party library that you want to integrate into your Android app.
      * **Direct Hardware Access:** In rare cases requiring closer interaction with hardware that isn't fully exposed through Java APIs.
        For most standard app development, Java or Kotlin is sufficient and more efficient.

13. **Explain the concept of "Binder" in Android and its role in Inter-Process Communication (IPC).**
    "Binder" is Android's core, high-performance Inter-Process Communication (IPC) mechanism. It's fundamental because Android apps run in isolated Linux processes. Binder enables different processes to communicate by allowing a client process to invoke methods on an object (a service) that resides in a different, remote process as if it were a local object.
    Its role in IPC involves:

      * **Client-Server Model:** A server process exposes an interface (a Binder object), and client processes communicate with it.
      * **Kernel Driver:** At its core, Binder is a Linux kernel driver that efficiently handles the marshalling (packaging) and unmarshalling (unpacking) of data and method calls between the client and server processes' memory spaces.
      * **System Services:** Most core Android system services (e.g., ActivityManagerService, PackageManagerService) expose their functionalities through Binder interfaces, allowing applications to interact with the system.

14. **How does an Android app work internally from startup to execution?**
    When an app icon is tapped:

    1.  The Launcher sends an `Intent` to the `ActivityManagerService` (AMS) to start the app's main Activity.
    2.  AMS checks if the app's process exists. If not, it requests the `Zygote` process to fork a new child process for the app.
    3.  The new app process creates its own Android Runtime (ART) instance and starts the `ActivityThread` (the app's main UI thread).
    4.  The `Application` class (if extended) is instantiated, and its `onCreate()` method is called for global initialization.
    5.  AMS instructs the `ActivityThread` to launch the requested `Activity`. The `Activity` instance is created, and its `onCreate()`, `onStart()`, and `onResume()` lifecycle methods are called in sequence, setting up and displaying the UI.
    6.  The app's main thread then enters an event loop (`Looper` and `Handler`), continuously processing UI events (user input, drawing) and system messages, ensuring the UI remains responsive.

15. **What is the Android Zygote process and its role in app launching?**
    The Android Zygote process is a special, pre-initialized daemon process that starts when the Android system boots up. Its name, "Zygote," signifies its role as a "parent" from which all other application processes are "forked."
    Its role in app launching is crucial for efficiency:

      * **Pre-initialization:** Zygote creates a new ART/Dalvik VM and pre-loads all common Android framework classes and resources into memory.
      * **Faster App Startup:** When a new app needs to be launched, the `ActivityManagerService` instructs Zygote to `fork()` a new child process. This child process inherits the pre-initialized VM and loaded classes via a "copy-on-write" mechanism.
      * **Memory Efficiency:** By sharing common framework code and resources, Zygote significantly reduces the memory footprint of individual app processes and dramatically speeds up application launch times compared to starting a new VM from scratch for every app.

## Core Components

16. **What are the four main components of an Android application and their purposes?**
    The four main components are fundamental building blocks of an Android app:

      * **Activities:** Represent a single screen with a user interface. They are the primary point of interaction for users and handle UI and user input.
      * **Services:** Perform long-running operations in the background, without a user interface. They are used for tasks like playing music, downloading files, or data synchronization.
      * **Broadcast Receivers:** Components that allow an application to listen for and respond to system-wide broadcast announcements (e.g., low battery, incoming SMS) or custom broadcasts from other apps.
      * **Content Providers:** Manage access to a structured set of data. They provide a standard interface for applications to query, insert, update, or delete data, and are primarily used for securely sharing data between different applications.

17. **What is the Application class and when would you extend it?**
    The `Application` class is the base class for maintaining global application state across all components of your app. A single instance of this class exists for the entire lifetime of your application process.
    You would extend the `Application` class when you need to perform:

      * **Global, One-Time Initializations:** Setting up third-party libraries (e.g., analytics, crash reporting), initializing databases (like Room), or configuring global services that need to be ready as soon as the app process starts.
      * **Managing Global State:** Storing data or objects that need to be accessible across different activities, services, or fragments, though for most data, architectural components like `ViewModel` or a dedicated data layer are often preferred.
      * **Registering for Application-Level Callbacks:** Observing activity lifecycle changes across your entire app using `ActivityLifecycleCallbacks`.

18. **How do you register components in AndroidManifest.xml?**
    All four main Android components must be declared in the `AndroidManifest.xml` file within the `<application>` tag.

      * **Activities:** Using the `<activity>` tag (e.g., `<activity android:name=".MainActivity" android:exported="true">`).
      * **Services:** Using the `<service>` tag (e.g., `<service android:name=".MyService" android:exported="false">`).
      * **Broadcast Receivers:** Using the `<receiver>` tag (e.g., `<receiver android:name=".MyReceiver" android:exported="true">`).
      * **Content Providers:** Using the `<provider>` tag (e.g., `<provider android:name=".MyContentProvider" android:authorities="com.example.myapp.provider" android:exported="false">`).
        Each declaration typically includes the `android:name` attribute specifying the fully qualified class name, and often `android:exported` and `intent-filter` elements to define their availability and respond to `Intent`s.

19. **What is the component lifecycle and how does Android manage it?**
    The component lifecycle refers to the various states an Android application component (like an Activity, Fragment, or Service) can transition through from its instantiation to its destruction. Android manages these lifecycles strictly to ensure resource efficiency and maintain system stability.
    Android manages lifecycles through:

      * **Callback Methods:** When a component's state changes (e.g., it comes to the foreground, goes to the background, or is destroyed), the system invokes specific callback methods (e.g., `onCreate()`, `onStart()`, `onPause()`, `onDestroy()`) on that component.
      * **System Decisions:** The Android system makes decisions about component state based on user interaction, resource availability (e.g., low memory), and other system events. Developers override these callback methods to perform appropriate actions (setup, cleanup, saving state) at each lifecycle stage.

20. **Explain the concept of component activation and deactivation.**

      * **Activation:** Refers to a component becoming ready for user interaction or actively performing its intended function. For an Activity, this means it's in the foreground, visible, and able to receive user input, typically corresponding to reaching the `onResume()` state. For a Service, it means it's running and performing its background task.
      * **Deactivation:** Refers to a component moving out of the active state, either by becoming obscured, moving to the background, or stopping its primary function. For an Activity, this could mean entering `onPause()` (partially obscured) or `onStop()` (fully hidden). For a Service, it might involve being unbound or stopped. Deactivation often prompts resource release to save battery and memory.

## Activities

21. **Explain the complete Activity lifecycle with all callback methods.**
    The Activity lifecycle describes the sequence of states an Activity goes through. Here are the main callback methods:

      * `onCreate(Bundle savedInstanceState)`: Called once when the activity is first created. Perform static setup like `setContentView()`, view bindings, and initial data loading.
      * `onStart()`: Called when the activity becomes visible to the user.
      * `onResume()`: Called when the activity is in the foreground and the user can interact with it. This is where you typically start animations, acquire exclusive device access (e.g., camera).
      * `onPause()`: Called when the activity is partially obscured or about to lose user focus (e.g., a dialog appears, another activity comes to foreground). Save any unsaved user data here and stop CPU-intensive work.
      * `onStop()`: Called when the activity is no longer visible to the user. Release most resources that are not needed when the activity is not visible.
      * `onDestroy()`: Called before the activity is destroyed. Perform final cleanup (e.g., unregister broadcast receivers, release large resources).
      * `onRestart()`: Called when the activity that was in the "Stopped" state is about to be re-displayed to the user. Always followed by `onStart()`.

22. **What's the difference between onCreate() and onStart()?**
    `onCreate()` is the very first callback received when an Activity instance is created. It is called *only once* during the entire lifetime of an activity. It's for essential setup.
    `onStart()` is called when the Activity becomes visible to the user. It can be called *multiple times* during the activity's lifetime (e.g., when the user navigates back to it from another activity, or after the activity was in `onStop()` and is being resumed).

23. **Why is setContentView() typically called in onCreate()?**
    `setContentView()` is typically called in `onCreate()` because it's responsible for inflating the activity's user interface layout from an XML file and setting it as the content view for the activity. This UI setup is a one-time operation that needs to happen when the activity is first created, making `onCreate()` the most appropriate and efficient place for it. Calling it elsewhere might lead to redundant view inflation or issues with view availability.

24. **When might onDestroy() be called without onPause() and onStop()?**
    In normal Android operation, `onDestroy()` is always preceded by `onPause()` and `onStop()`. It's highly unusual for `onDestroy()` to be called directly.
    However, this *could* potentially happen in rare, abnormal termination scenarios such as:

      * An unhandled crash (runtime exception) in the activity that immediately kills the process.
      * The system forcibly kills the app's process due to extreme low memory conditions, especially if the activity was already in the background and its process was a prime candidate for termination.
        These are not part of the graceful lifecycle flow.

25. **What is the purpose of onSaveInstanceState() and onRestoreInstanceState()?**

      * **`onSaveInstanceState(Bundle outState)`:** This callback is invoked by the system before an activity might be killed to free up resources (e.g., during configuration changes like screen rotation, or when the system needs memory and destroys a background activity). Its purpose is to allow you to save transient, dynamic UI state (like text in an `EditText`, scroll position of a `RecyclerView`, or a selected tab) into the provided `Bundle`. This `Bundle` is then automatically saved by the system.
      * **`onRestoreInstanceState(Bundle savedInstanceState)`:** This callback is invoked *after* `onStart()` (and after `onCreate()`, if the activity was recreated) if the activity is being recreated after being previously destroyed by the system. Its purpose is to retrieve the saved state from the `Bundle` provided by the system, allowing you to restore the UI to its previous state. It's often replaced by checking the `savedInstanceState` `Bundle` in `onCreate()`.

26. **How does an Activity handle screen rotation and configuration changes?**
    By default, when a significant configuration change occurs (like screen rotation, keyboard availability, or language change), Android destroys the current Activity instance and then recreates it.

      * The system calls `onSaveInstanceState()` on the old instance to save its dynamic state.
      * The old instance goes through `onPause()`, `onStop()`, and `onDestroy()`.
      * A new instance of the Activity is created.
      * The new instance goes through `onCreate()` (receiving the saved `Bundle`), `onStart()`, and `onResume()`.
        This default behavior ensures that your app can load appropriate resources (e.g., landscape layouts) for the new configuration.

27. **How can you preserve Activity state during configuration changes?**
    Several methods can be used to preserve state during configuration changes:

    1.  **`onSaveInstanceState()` and `onRestoreInstanceState()`:** For saving small, UI-related primitive data or `Parcelable`/`Serializable` objects.
    2.  **`ViewModel` (Recommended):** The most common and robust way. `ViewModel` instances automatically survive configuration changes and process death, allowing you to store and manage UI-related data that is independent of the Activity's lifecycle.
    3.  **`android:configChanges` in Manifest:** By declaring specific configuration changes (e.g., `android:configChanges="orientation|screenSize"`) in your `AndroidManifest.xml`, you prevent the Activity from being recreated. Instead, the Activity receives a call to `onConfigurationChanged(Configuration newConfig)`, and you handle the changes manually. Use this cautiously as it bypasses default system behavior and can make handling resource changes more complex.
    4.  **Retained Fragments:** A Fragment can be marked as `setRetainInstance(true)` to survive configuration changes, often used to retain background tasks or `ViewModel`s (though `ViewModel` itself handles this directly now).

28. **Is it possible to create an Activity without a user interface?**
    Yes, it is possible to create an Activity without a user interface. You would simply **not call `setContentView()`** in its `onCreate()` method. Such an Activity can be used for:

      * Performing background operations that require an Activity context (though a `Service` is usually more appropriate for long-running background tasks).
      * Acting as a transparent intermediary or "stub" for specific system interactions.
      * Hosting a `Fragment` that itself provides the UI, while the Activity remains technically "UI-less."
        You can also make an Activity appear transparent by applying a theme like `Theme.AppCompat.Translucent.NoTitleBar` in the manifest.

29. **What happens when the system kills your app process?**
    When the Android system kills your app's process (e.g., due to low memory, user explicitly force-stopping the app, or a severe crash), the entire process, along with all its running components (Activities, Services, Broadcast Receivers), is terminated abruptly.

      * No further lifecycle callbacks (`onDestroy()`) are guaranteed to be called if the termination is sudden.
      * All data held in memory by the app's process is lost.
      * If the user later navigates back to your app, the system will start a new process and attempt to recreate the last visible Activity, relying on `onSaveInstanceState()` to restore its state if it was correctly implemented.

30. **How do you handle Activity recreation scenarios?**
    Handling Activity recreation is crucial for maintaining a good user experience. The primary strategies are:

      * **Use `ViewModel` (Primary Solution):** For UI-related data that should persist across configuration changes and process death. `ViewModel`s outlive their associated Activity instances.
      * **Implement `onSaveInstanceState()` and `onRestoreInstanceState()`:** For saving small amounts of transient UI state (e.g., scroll position, selected item) within the `Bundle`. This bundle is provided to `onCreate()` and `onRestoreInstanceState()` on recreation.
      * **Utilize `SavedStateHandle` (with `ViewModel`):** A `Map<String, Any?>` that allows `ViewModel`s to directly access and save state into the `Bundle` that `onSaveInstanceState()` would provide, simplifying state management.
      * **Persist Non-UI Data:** For application data that needs to survive process death (e.g., user profiles, app settings), store it in persistent storage like Room database, SharedPreferences, or files.

31. **What is the difference between finish() and finishAffinity()?**

      * **`finish()`:** This method is called on an Activity to close only the *current* Activity instance. It removes this specific Activity from the top of the back stack. The user will then return to the previous Activity in the stack.
      * **`finishAffinity()`:** This method finishes the *current* Activity and all Activities that are part of the *same task and have the same task affinity*. It's typically used when you want to exit a specific "flow" of activities within your application and clear the entire task associated with it, effectively taking the user back to the home screen or the previous app.

32. **Explain task affinity and its impact on Activity behavior.**
    Task affinity is an attribute that indicates which "task" an Activity prefers to belong to. By default, all Activities in an application have the same task affinity, which is the application's package name.
    Its impact on Activity behavior includes:

      * **Task Assignment:** It influences where an Activity is launched when using flags like `FLAG_ACTIVITY_NEW_TASK`. An Activity with `FLAG_ACTIVITY_NEW_TASK` will attempt to launch into an existing task with the same affinity, or create a new one if none exists.
      * **`finishAffinity()` Behavior:** As explained above, `finishAffinity()` relies on task affinity to determine which activities to finish.
      * **`allowTaskReparenting`:** This manifest attribute works with task affinity. If an Activity has `allowTaskReparenting="true"`, it can move from the task it was started in to a task it has an affinity for when that task is brought to the foreground.

## Launch Modes

33. **Explain different launch modes (standard, singleTop, singleTask, singleInstance).**
    Launch modes determine how a new instance of an Activity is created and how it relates to the task (back stack) it's placed in. They are set in `AndroidManifest.xml` using `android:launchMode`.

      * **`standard` (default):** A new instance of the Activity is created every time it's launched, and it's placed on top of the task stack that launched it.
      * **`singleTop`:** If an instance of the Activity already exists at the *top* of the calling task's stack, a new instance is *not* created. Instead, the existing instance receives the new Intent through its `onNewIntent()` callback. If it's not at the top, a new instance is created.
      * **`singleTask`:** The system checks if an instance of the Activity already exists in *any* task. If it does, that instance is brought to the foreground, and all other Activities on top of it in that task are cleared. If no instance exists, a new task is created for it, and the Activity becomes the root of that new task.
      * **`singleInstance`:** Similar to `singleTask`, but the Activity becomes the *sole* Activity in its new task. No other Activities can be launched into the same task as this `singleInstance` Activity. Any Activities launched from it will go into a separate, new task.

34. **What's the difference between FLAG\_ACTIVITY\_CLEAR\_TASK and FLAG\_ACTIVITY\_CLEAR\_TOP?**
    These are `Intent` flags that modify launch behavior, often used with `startActivity()`:

      * **`FLAG_ACTIVITY_CLEAR_TASK`:** Used in conjunction with `FLAG_ACTIVITY_NEW_TASK`. When these flags are set, the system clears *all* existing activities from the task that the new activity is being launched into, and then starts the new activity as the root of that now empty task. This effectively creates a completely fresh task stack for the new activity.
      * **`FLAG_ACTIVITY_CLEAR_TOP`:** If the activity being launched already exists somewhere in the current task's back stack, all activities on top of that existing instance are cleared from the stack. The existing instance is brought to the top and receives the new Intent via `onNewIntent()`. If the activity does not exist in the stack, a new instance is created normally.

35. **How do launch modes affect the back stack?**

      * **`standard`:** Always adds a new instance to the top of the current task's back stack.
      * **`singleTop`:** If the target Activity is already at the top, no new instance is added; `onNewIntent()` is called. Otherwise, a new instance is added to the top.
      * **`singleTask`:** If an instance exists, it brings its task to the foreground and clears (pops) all Activities above it in that task's stack. If no instance exists, it creates a new task and becomes its root.
      * **`singleInstance`:** Creates a *new, dedicated task* for itself, and it is the *only* Activity allowed in that task. Any subsequent Activities launched from it will automatically be placed in a *different* task.

36. **When would you use singleInstance launch mode?**
    You would use `singleInstance` launch mode when you need an Activity to be a globally unique instance and the sole Activity in its own dedicated task. This is typically used for:

      * **Application entry points that act as central hubs:** For example, a dashboard Activity from which the user can branch off into various distinct parts of the application, and you always want this specific dashboard to be unique and clear of other Activities.
      * **Activities that are integrated as part of the system or interact extensively with external apps:** Where maintaining a single instance and isolated task behavior is critical to prevent unexpected back stack interactions.
        However, it's generally used sparingly due to its strict task isolation, which can lead to complex navigation scenarios.

37. **What are Intent flags and how do they modify Activity behavior?**
    Intent flags are integer constants that can be added to an `Intent` object using `addFlags()`. They provide instructions to the Android system on how to launch an Activity, how to interact with the task stack, or how to treat the Intent itself. They effectively modify the default behavior of `startActivity()`.
    Examples:

      * `FLAG_ACTIVITY_NEW_TASK`: Launches the Activity in a new task (or moves it to an existing one).
      * `FLAG_ACTIVITY_SINGLE_TOP`: Behaves like `singleTop` launch mode for the current `startActivity()` call.
      * `FLAG_ACTIVITY_NO_HISTORY`: The launched Activity will not be kept in the activity stack.
      * `FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS`: Excludes the task from the recent apps list.

38. **How do you clear the back stack when launching a new Activity?**
    You can clear the back stack when launching a new Activity primarily using Intent flags:

      * **To clear the entire current task and start a fresh one:**
        `intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)`
        This will ensure that when the user presses back from the new activity, they will go to the home screen or the previous app, not to any activities from the app's previous task.
      * **To clear activities on top of an existing instance of the target Activity:**
        `intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)`
        This is often combined with `FLAG_ACTIVITY_SINGLE_TOP`. If the target Activity is already in the stack, all activities above it are removed.

## Fragments

39. **What is a Fragment and how does it differ from an Activity?**
    A Fragment represents a modular portion of a user interface or behavior that can be placed inside an Activity. It has its own lifecycle, input events, and can be added or removed while the host Activity is running.
    Key differences from an Activity:

      * **Modularity/Reusability:** Fragments are designed to be modular and reusable across multiple Activities or within the same Activity for different layouts (e.g., tablet vs. phone).
      * **Host Dependency:** A Fragment *must* always be hosted by an Activity (or another Fragment). It cannot exist independently.
      * **Lifecycle:** While a Fragment has its own lifecycle, it's closely tied to and influenced by its host Activity's lifecycle.
      * **UI Portion:** Fragments typically represent a *part* of the UI, whereas an Activity typically represents a single, entire screen.

40. **Explain the Fragment lifecycle and its key callback methods.**
    The Fragment lifecycle is distinct but intertwined with its host Activity's lifecycle. Key callback methods include:

      * `onAttach(Context context)`: Called when the fragment has been associated with its host activity.
      * `onCreate(Bundle savedInstanceState)`: Called when the fragment is being created. Perform non-UI initializations (similar to Activity's `onCreate`).
      * `onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)`: Called to create and return the Fragment's UI view hierarchy. This is where you inflate your layout.
      * `onViewCreated(View view, Bundle savedInstanceState)`: Called immediately after `onCreateView()` has returned, and the view hierarchy is fully created. Perform view-related setup here (e.g., `findViewById`, attaching listeners).
      * `onActivityCreated(Bundle savedInstanceState)` (Deprecated): Called when the host Activity's `onCreate()` method has completed. Use `onViewCreated()` or `onStart()` for logic that depends on the host's Activity views.
      * `onStart()`: Fragment becomes visible.
      * `onResume()`: Fragment is in the foreground and active.
      * `onPause()`: Fragment is no longer interactive.
      * `onStop()`: Fragment is no longer visible.
      * `onDestroyView()`: Called when the view hierarchy associated with the fragment is being removed. Clean up view-specific resources.
      * `onDestroy()`: Fragment is being destroyed. Perform final cleanup.
      * `onDetach()`: Called when the fragment is being disassociated from its host activity.

41. **Which method is called only once in a Fragment lifecycle?**
    `onAttach()` and `onCreate()` are typically called only once for a given Fragment instance during its lifecycle, unless the Fragment is explicitly destroyed and recreated by the system or `FragmentManager`.

42. **What is the difference between onCreateView() and onViewCreated()?**

      * **`onCreateView()`:** This method is responsible for **inflating the Fragment's user interface layout** from an XML resource and returning the root `View` of that hierarchy. At this point, the views are inflated but not yet fully configured or available for direct manipulation.
      * **`onViewCreated()`:** This method is called immediately *after* `onCreateView()` returns. At this stage, the Fragment's views are fully created, initialized, and available. This is the ideal place to perform view-related setup, such as finding views by ID (`findViewById`), setting up adapters for `RecyclerView`s, or attaching event listeners.

43. **How do you communicate between Fragment and Activity?**
    Several recommended ways:

      * **Interface (Callback Pattern):** Define an interface in the Fragment. The host Activity implements this interface. The Fragment then calls the interface method to send data or events back to the Activity. This is a robust, decoupled approach.
      * **`ViewModel` (Shared):** Use a `ViewModel` scoped to the host Activity. Both the Fragment and the Activity can observe `LiveData` or `StateFlow` from this shared `ViewModel` to exchange data.
      * **`Fragment Result API`:** For passing one-time results back from a child Fragment or a called Fragment to its parent/calling Fragment or Activity.

44. **How do you communicate between two Fragments?**

      * **Shared `ViewModel` (Recommended):** The most common and robust way. Both Fragments can share a `ViewModel` that is scoped to their common host Activity or to a navigation graph. One Fragment updates data (e.g., `LiveData`, `StateFlow`) in the `ViewModel`, and the other observes it.
      * **Through Host Activity:** Fragment A communicates with its host Activity (e.g., via an interface or shared `ViewModel`), and the Activity then relays the information to Fragment B (e.g., by calling a method on Fragment B, or updating a shared `ViewModel`).
      * **`Fragment Result API`:** For one-off result passing, where one Fragment initiates an action and another returns a result.

45. **What are retained Fragments and when are they useful?**
    A retained Fragment is a Fragment instance that is specifically marked to *not be destroyed* when its host Activity is recreated due to a configuration change (like screen rotation). You mark it by calling `setRetainInstance(true)` in its `onCreate()`.
    They were historically useful for retaining objects like `AsyncTask`s, background threads, or large data objects that are expensive to re-initialize during configuration changes. However, with the advent of `ViewModel`, which handles this persistence automatically and more cleanly, the use of directly retained Fragments for UI state is largely discouraged. They are still useful for "headless" background tasks.

46. **How do you handle back navigation within Fragments?**

      * **`FragmentManager` Back Stack:** When performing `FragmentTransaction`s, call `addToBackStack(String name)` before `commit()`. This pushes the transaction onto the `FragmentManager`'s back stack. When the user presses the back button, the top transaction is popped, reversing its operations.
      * **`OnBackPressedCallback` (Recommended for custom logic):** For more fine-grained control or conditional back navigation within a Fragment, use `OnBackPressedCallback` from `androidx.activity:activity-ktx`. You can register a callback in the Fragment's `onCreateView()` or `onViewCreated()` that intercepts back presses and performs custom actions. You can then optionally call `isEnabled = false` on the callback to allow default behavior if your custom logic doesn't fully handle the back press.

47. **Why use only default constructor for Fragments?**
    You should only use the default (no-argument) constructor for Fragments because the Android framework system needs to be able to recreate your Fragment instance in various scenarios (e.g., after a configuration change like screen rotation, or after the app's process has been killed by the system). If you define a custom constructor with arguments, the system won't know how to provide those arguments during recreation, leading to instantiation errors and crashes. Arguments should always be passed to Fragments via a `Bundle` using `setArguments()`.

48. **How do you pass arguments to a Fragment safely?**
    The safest and recommended way to pass arguments to a Fragment is by using a `Bundle` and the `setArguments()` method:

    1.  Create a `Bundle` object.
    2.  Use `bundle.putInt()`, `bundle.putString()`, `bundle.putParcelable()`, etc., to add your arguments to the `Bundle`.
    3.  Call `fragmentInstance.setArguments(bundle)` before adding/replacing the Fragment.
    4.  In the Fragment's `onCreate()` (or `onViewCreated()`), retrieve the arguments using `requireArguments().getInt("key")` or `getArguments()?.getString("key")`.
        **Safe Args Gradle Plugin:** For compile-time type safety and simplified argument passing, the Navigation component's Safe Args plugin is highly recommended.

49. **What's the difference between Fragment add() and replace() operations?**
    Both `add()` and `replace()` are methods of `FragmentTransaction` for managing Fragments within a container:

      * **`add(containerId, fragment)`:** Adds the specified Fragment to the container. Any existing Fragments in that container are *retained* but might be obscured by the new Fragment. Their `onDestroyView()` is *not* called. This is useful for overlapping UIs, like a transparent dialog Fragment.
      * **`replace(containerId, fragment)`:** Removes any existing Fragments from the specified container and adds the new Fragment in their place. The `onDestroyView()` and `onDestroy()` (if not added to back stack) callbacks are called on the replaced Fragments' views. This is the more common operation for swapping out entire UI sections.

50. **What is FragmentManager and FragmentTransaction?**

      * **`FragmentManager`:** This is the class responsible for managing Fragments within an Activity. It provides methods to add, remove, replace, and perform other operations on Fragments. It also manages the Fragment back stack and interaction with nested Fragments. You get an instance by calling `getSupportFragmentManager()` (for AndroidX) from an Activity or Fragment.
      * **`FragmentTransaction`:** A class that allows you to perform a set of Fragment operations (like `add()`, `remove()`, `replace()`, `hide()`, `show()`, `attach()`, `detach()`) as a single, atomic unit. You begin a transaction (`beginTransaction()`), perform one or more operations, and then `commit()` the transaction for the changes to take effect. It also supports `addToBackStack()` for back navigation.

51. **How do you handle Fragment back stack?**
    You handle the Fragment back stack using `FragmentManager` and `FragmentTransaction`.

      * When performing a `FragmentTransaction` (e.g., `replace()` or `add()`) that you want to be reversible by the back button, call `fragmentTransaction.addToBackStack(String name)` before `commit()`. The `name` is optional but can be used to pop specific states.
      * When the user presses the back button, the `FragmentManager` automatically pops the top transaction from its back stack, reversing the operations (e.g., showing the previously replaced Fragment).
      * You can programmatically pop the back stack using `fragmentManager.popBackStack()` or `popBackStackImmediate()`.

52. **What are headless Fragments and their use cases?**
    A headless Fragment is a Fragment that does not have a user interface associated with it. Its `onCreateView()` method returns `null`. They are typically created with `setRetainInstance(true)` (though less necessary with `ViewModel`s now).
    **Use cases:**

      * **Retaining Background Operations:** Managing long-running background tasks (e.g., network requests, database operations) that need to persist across Activity re-creations due to configuration changes.
      * **Managing Non-UI State:** Holding onto an object (like a `ViewModel` for older architectures, or a specific manager class) that needs to survive Activity destruction and recreation.
      * **Providing Callbacks:** Acting as a bridge between an asynchronous task and the Activity, delivering results back to the recreated Activity instance.

## Intents & Navigation

53. **What is an Intent and explain implicit vs explicit Intents with examples.**
    An `Intent` is a messaging object that an Android component can use to request an action from another component. It's a way for components to communicate with each other.

      * **Explicit Intent:** Clearly specifies the target component (Activity, Service, Broadcast Receiver) by its fully qualified class name. Used when you know exactly which component you want to start within your own app.
          * **Example:** `val intent = Intent(this, DetailActivity::class.java); startActivity(intent)`
      * **Implicit Intent:** Declares a general action to be performed, along with the data on which to perform it. The Android system then finds a component on the device that can handle that action and data. Used to launch components outside your app, or to allow your app to be launched by other apps.
          * **Example:** `val intent = Intent(Intent.ACTION_VIEW, Uri.parse("http://www.google.com")); startActivity(intent)` (opens web browser)

54. **What are Intent Filters and how do they work?**
    Intent Filters are declarations in the `AndroidManifest.xml` file that specify the capabilities of an application component (Activity, Service, or Broadcast Receiver). They tell the Android system what types of `Intent`s that component can respond to.
    They work by defining:

      * **`<action>`:** The general action to be performed (e.g., `ACTION_VIEW`, `ACTION_SEND`).
      * **`<data>`:** The type of data (MIME type) and/or URI scheme, host, path that the component can handle (e.g., `http://`, `content://`).
      * **`<category>`:** Provides additional information about the component's category or context (e.g., `CATEGORY_LAUNCHER`, `CATEGORY_BROWSABLE`).
        When an implicit `Intent` is broadcast, the system compares its action, data, and categories against the `Intent Filters` declared by various components to find a suitable match.

55. **How do you pass data between Activities using Intents?**
    You pass data between Activities using `Intent` "extras."

    1.  **Sending Activity:** Create an `Intent`, then use `intent.putExtra(key, value)` methods to add data. `putExtra()` supports primitives (int, String, boolean), arrays, `Bundle`s, and `Parcelable` or `Serializable` objects.
          * `val intent = Intent(this, TargetActivity::class.java)`
          * `intent.putExtra("user_id", 123)`
          * `intent.putExtra("user_name", "Alice")`
          * `startActivity(intent)`
    2.  **Receiving Activity:** In the `onCreate()` method of the target Activity, retrieve the `Intent` using `getIntent()`, then access the extras `Bundle` to get the data.
          * `val userId = intent.getIntExtra("user_id", -1)`
          * `val userName = intent.getStringExtra("user_name")`

56. **What is a PendingIntent and its common use cases?**
    A `PendingIntent` is a token that grants a foreign application (another app, the system, or a different process) permission to use your application's `Intent` on your behalf, with the permissions and identity of your application. It acts as a wrapper around an `Intent`.
    Common use cases:

      * **Notifications:** Tapping a notification to launch an Activity.
      * **App Widgets:** Clicking a button on a home screen widget to perform an action.
      * **`AlarmManager`:** Scheduling a future event or task to be executed by your app at a specific time, even if your app is not running.
      * **SMS/MMS operations:** Sending or receiving messages.

57. **What is a Sticky Intent?**
    A "Sticky Intent" is a type of broadcast that, after being sent, remains cached by the system so that new `BroadcastReceiver`s registered for it will immediately receive its last broadcast value. For example, `ACTION_BATTERY_CHANGED` is a sticky broadcast.
    **Note:** `Context.sendStickyBroadcast()` is deprecated since API 21 due to security and performance implications. `LocalBroadcastManager` (for within-app sticky behavior) or more robust data persistence solutions are preferred for new development.

58. **How do you handle deep linking in Android?**
    Deep linking allows a specific URL (e.g., from a website, email, or another app) to open directly into particular content or a specific screen within your Android application.
    To handle deep linking:

    1.  **Define Intent Filters in `AndroidManifest.xml`:** For the Activity that should handle the deep link, add an `<intent-filter>` with:
          * `<action android:name="android.intent.action.VIEW" />`
          * `<category android:name="android.intent.category.DEFAULT" />`
          * `<category android:name="android.intent.category.BROWSABLE" />`
          * `<data>` tags specifying the `android:scheme` (e.g., `http`, `https`, or a custom scheme like `myapp`), `android:host`, and `android:pathPrefix` (or `path` or `pathPattern`) that your app can handle.
    2.  **Handle the Incoming Intent:** In the target Activity's `onCreate()` and `onNewIntent()` methods, retrieve the `Uri` from the incoming `Intent` using `intent.getData()`. Parse this `Uri` to extract relevant parameters and navigate the user to the correct content within your app.
    3.  **App Links (for HTTP/HTTPS):** For standard web URLs, use `android:autoVerify="true"` in your `<data>` tag and host an `assetlinks.json` file on your domain to enable App Links for secure, verified deep linking.

59. **What are Intent actions and categories?**
    `Intent` actions and categories are key components of an `Intent` filter that help Android determine which component should receive an implicit `Intent`:

      * **Actions (`<action>`):** A string that specifies the general action to be performed (e.g., `android.intent.action.VIEW` for displaying data, `android.intent.action.SEND` for sending data, `android.intent.action.MAIN` for the app's primary entry point).
      * **Categories (`<category>`):** A string that provides additional information about the kind of component that should handle the Intent, or the context in which it should be handled (e.g., `android.intent.category.LAUNCHER` for the app's icon in the app drawer, `android.intent.category.BROWSABLE` for a web link that can be opened by a browser).

60. **How do you create custom Intent actions?**
    You create custom Intent actions by defining a unique string constant and declaring it in the `AndroidManifest.xml` of the component that will respond to it.

    1.  **Define a unique string:** `const val ACTION_SHOW_DETAIL = "com.example.myapp.ACTION_SHOW_DETAIL"`
    2.  **Declare in Manifest:** In the `<intent-filter>` of your target Activity (or Service/Receiver), add an `<action>` tag with your custom string:
        ```xml
        <activity android:name=".DetailActivity">
            <intent-filter>
                <action android:name="com.example.myapp.ACTION_SHOW_DETAIL" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        ```
    3.  **Use in Code:** When sending the Intent: `val intent = Intent("com.example.myapp.ACTION_SHOW_DETAIL")`

61. **What is the difference between startActivity() and startActivityForResult()?**

      * **`startActivity(Intent intent)`:** Launches a new Activity and simply moves to it without expecting any data or result back from that Activity. It's a "fire and forget" mechanism.
      * **`startActivityForResult(Intent intent, int requestCode)` (Deprecated):** This method was used to launch a new Activity with the expectation that it would return a result back to the calling Activity. The result was delivered via the `onActivityResult(int requestCode, int resultCode, Intent data)` callback. The `requestCode` was used to identify which request the result belonged to. This method is now deprecated.

62. **How do you handle Activity results with the new Activity Result API?**
    The new Activity Result API, part of AndroidX Activity library, provides a safer and more structured way to handle Activity results, replacing the deprecated `startActivityForResult()`.

    1.  **Register a callback:** In the calling Activity or Fragment, register an `ActivityResultLauncher` instance using `registerForActivityResult()`, specifying an `ActivityResultContract` (e.g., `ActivityResultContracts.StartActivityForResult()`) and a lambda callback to handle the result.
        ```kotlin
        val someActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                val data: Intent? = result.data
                // Handle the data from the result Intent
            }
        }
        ```
    2.  **Launch the Activity:** To start the target Activity, call `someActivityResultLauncher.launch(intent)`.
        This API is lifecycle-aware, reducing boilerplate and potential issues with lifecycle events.

63. **What are scheme-based and app link deep links?**
    These are two types of deep links:

      * **Scheme-based Deep Links (Custom Scheme URLs):** Use custom URI schemes (e.g., `myapp://product/123`). When a user clicks such a link, the system looks for an app registered to handle that custom scheme. The downside is that multiple apps can declare the same custom scheme, leading to a disambiguation dialog (user choice) or potential security issues.
      * **App Links (HTTP/HTTPS Deep Links):** These are standard HTTP/HTTPS URLs (e.g., `https://www.example.com/product/123`). They offer stronger security and a better user experience because they are verified. If your app is verified to own the domain (via a Digital Asset Links JSON file on your web server), clicking the link will directly open your app, bypassing the disambiguation dialog and opening a browser. If verification fails, it falls back to a regular web link.

64. **How do you verify app links?**
    App Links verification is a crucial step for making your HTTP/HTTPS deep links work seamlessly. It involves two main parts:

    1.  **Digital Asset Links JSON file on your website:**
          * You host a `assetlinks.json` file at `https://yourdomain.com/.well-known/assetlinks.json`.
          * This file contains metadata about your Android app, specifically its `package_name` and the `sha256_cert_fingerprints` of your app's signing key.
    2.  **`android:autoVerify="true"` in `AndroidManifest.xml`:**
          * In the `<data>` tag of your deep link's `intent-filter`, you include `android:autoVerify="true"`.
          * When your app is installed, the Android system automatically attempts to fetch the `assetlinks.json` file from your specified domains and verifies that the app's signing certificate matches what's declared in the JSON file. If the verification succeeds, your app becomes the default handler for those URLs.

## Services & Background Processing

65. **What is a Service and explain its lifecycle?**
    A Service is an application component that can perform long-running operations in the background, without a user interface. It runs independently of an Activity's lifecycle and can continue to run even if the user navigates away from your app or the Activity is destroyed.
    **Service Lifecycle:**

      * `onCreate()`: Called once when the service is first created. Perform initial setup here.
      * `onStartCommand(Intent intent, int flags, int startId)`: Called when a client starts the service by calling `startService()`. The service begins a background operation. The return value (e.g., `START_STICKY`, `START_NOT_STICKY`) indicates how the system should handle the service if it's killed.
      * `onBind(Intent intent)`: Called when another component binds to the service by calling `bindService()`. It must return an `IBinder` object that provides the communication interface.
      * `onUnbind(Intent intent)`: Called when all clients have disconnected from the service.
      * `onDestroy()`: Called when the service is no longer used and is being shut down. Perform final cleanup and release resources.

66. **What is the difference between started Service and bound Service?**

      * **Started Service:** A service is "started" when an application component calls `startService()`. It typically performs a single, independent background operation (e.g., downloading a file, playing music) and runs indefinitely until it explicitly stops itself using `stopSelf()` or another component stops it with `stopService()`. It continues running even if the component that started it is destroyed.
      * **Bound Service:** A service is "bound" when an application component calls `bindService()`. It provides a client-server interface, allowing components to interact with the service (e.g., controlling a music player). The service runs only as long as at least one client component is bound to it. When all clients unbind, the service is destroyed.

67. **What is the difference between Service, IntentService, and JobIntentService?**

      * **`Service`:** A general-purpose background component. It runs on the app's *main thread* by default, so long-running operations within a `Service` require you to manage your own background threads. Can be started or bound.
      * **`IntentService` (Deprecated since API 30):** A subclass of `Service` designed to simplify background work. It handles Intents asynchronously on a dedicated *worker thread*. It processes one Intent at a time in a queue and automatically stops itself when all work is done. It was suitable for simple, fire-and-forget background tasks.
      * **`JobIntentService` (Recommended replacement for `IntentService`):** A compatibility class that works similarly to `IntentService` but intelligently uses `JobScheduler` on Android 8.0 (API 26) and higher, and falls back to `Context.startService()` for older versions. This helps your app conform to background execution limits on newer Android versions and ensures work is handled efficiently and reliably.

68. **What are the differences between Service and Thread?**

      * **`Service`:** An Android application component. It's managed by the Android system and provides a way to perform long-running operations *independently of the UI lifecycle*, meaning it can continue running even if the app's Activity is not in the foreground. By default, a `Service` runs on the app's main thread, so for long tasks, it usually needs to create its own internal `Thread` or use a concurrency framework.
      * **`Thread`:** A fundamental Java/Kotlin concurrency primitive. It represents a single path of execution within a program. Threads are *not* Android components; they are not managed by the system's component lifecycle. If the app's process is killed, any `Thread`s within it are also terminated. Services often use `Thread`s (or higher-level constructs like `Executors` or Coroutines) internally to perform their actual background work off the main thread.

69. **How do you create and manage bound services?**

    1.  **Create Service Class:** Extend `Service` and override `onBind(Intent intent)`. This method must return an `IBinder` object, which is the communication interface clients will use. Typically, you'll create a custom `Binder` subclass inside your service.
        ```kotlin
        class MyBoundService : Service() {
            private val binder = MyBinder()
            inner class MyBinder : Binder() {
                fun getService(): MyBoundService = this@MyBoundService
            }
            override fun onBind(intent: Intent?): IBinder = binder
            // Add methods clients can call via the binder
            fun doSomething(): String = "Hello from bound service!"
        }
        ```
    2.  **Register in Manifest:** Declare the service in `AndroidManifest.xml` (e.g., `<service android:name=".MyBoundService" android:exported="false"/>`).
    3.  **Client Binds to Service:** In your Activity/Fragment, call `bindService()` with an `Intent` targeting your service and a `ServiceConnection` callback.
        ```kotlin
        private var myService: MyBoundService? = null
        private val connection = object : ServiceConnection {
            override fun onServiceConnected(className: ComponentName, service: IBinder) {
                val binder = service as MyBoundService.MyBinder
                myService = binder.getService()
                // Now you can call methods on myService
                Log.d("Service", myService?.doSomething() ?: "Service null")
            }
            override fun onServiceDisconnected(arg0: ComponentName) {
                myService = null
            }
        }
        // In Activity's onCreate or onStart:
        Intent(this, MyBoundService::class.java).also { intent ->
            bindService(intent, connection, Context.BIND_AUTO_CREATE)
        }
        ```
    4.  **Client Manages Unbinding:** Call `unbindService(connection)` when the client no longer needs the service, typically in `onStop()` or `onDestroy()` to prevent memory leaks.

70. **What is AIDL (Android Interface Definition Language)?**
    AIDL (Android Interface Definition Language) is a simple interface definition language (IDL) used to define a programming interface that allows client and service to agree upon the type of interprocess communication (IPC) that they will perform. You use AIDL when you need to perform IPC between different application processes, particularly when:

      * You need to allow multiple applications to access your service simultaneously.
      * You need to handle concurrent requests from different processes.
        AIDL is used to generate an interface file (e.g., `IMyAidlInterface.java`) that both the service and client can use for communication, abstracting the complexities of underlying Binder IPC.

71. **How do you communicate between Service and Activity?**

      * **Bound Service:** The most direct way. The Activity binds to the Service, and the Service provides an `IBinder` that allows the Activity to call public methods directly on the Service instance.
      * **`LocalBroadcastManager`:** For one-way communication from Service to Activity (or within the same app). The Service sends a local broadcast, and the Activity registers a `BroadcastReceiver` to listen for it. This is efficient and safe for within-app communication.
      * **`Messenger` / `Handler`:** For asynchronous, message-based communication, especially suitable for IPC if your service needs to be accessible by multiple clients across different processes.
      * **Shared Data (e.g., Database, SharedPreferences):** Both components can read/write to a common persistent data source.
      * **`EventBus` (third-party library):** A publish-subscribe pattern library that simplifies communication by allowing components to post and subscribe to events.

72. **What are foreground services and when to use them?**
    A foreground service is a type of service that is performing an operation that is noticeable to the user. Unlike a regular background service, a foreground service *must* display an ongoing notification to the user, providing transparency about its operation.
    **When to use them:**

      * For tasks that *must not be interrupted* by the system's battery optimizations (like Doze mode or App Standby).
      * When the service is performing an active task that the user is aware of and potentially interacting with (e.g., playing music, providing turn-by-turn navigation, recording exercise data, a call in progress).
        Using a foreground service tells the system that your app is performing important work and should not be killed.

73. **What is WorkManager and its primary use cases?**
    WorkManager is an Android Jetpack library (part of Architecture Components) for managing deferrable, guaranteed background work. It's the recommended solution for persistent tasks that need to run reliably even if the app exits or the device restarts. It handles compatibility across different Android versions and gracefully manages battery optimizations.
    **Primary Use Cases:**

      * **Guaranteed execution:** Tasks that *must* run eventually, regardless of app or device state.
      * **Network operations:** Syncing data with a backend, fetching new content, uploading logs.
      * **Content processing:** Applying filters to images, compressing data.
      * **Scheduled tasks:** Performing periodic data updates or cleanup.
      * **Tasks with constraints:** Running only when network is available, device is charging, or idle.

74. **What is JobScheduler and how does it work?**
    JobScheduler is a system API introduced in Android 5.0 (Lollipop) that provides a flexible and battery-efficient way to schedule various types of jobs. It allows apps to define conditions (e.g., network available, device charging, device idle) under which a task should run.
    **How it works:**

      * Developers define `JobInfo` objects specifying constraints for their work.
      * `JobScheduler` then batches these jobs from multiple applications and executes them efficiently when the specified conditions are met. This minimizes wake-ups and saves battery.
      * WorkManager uses JobScheduler internally on Android 5.0+ to fulfill its guaranteed and constrained work requests.

75. **How does WorkManager guarantee task execution?**
    WorkManager guarantees task execution through several mechanisms:

      * **Internal Database:** It stores all work requests in an internal SQLite database. This ensures that work persists across app restarts and even device reboots.
      * **Intelligent Delegation:** It intelligently chooses the most appropriate underlying system API for the task based on the device's API level and the work's constraints. This includes `JobScheduler` (for API 23+), `AlarmManager` + `BroadcastReceiver` (for older APIs), or even `Context.startService()` if needed, adapting to different platform behaviors and restrictions.
      * **Retries and Backoff:** It supports defining retry policies with exponential backoff for failed or interrupted tasks, ensuring they eventually complete.
      * **Constraints:** By allowing tasks to define required constraints (network, charging, idle), WorkManager ensures work is only attempted when success is most likely and battery drain is minimized.

76. **What is the minimum repeat interval for PeriodicWorkRequest?**
    The minimum repeat interval for a `PeriodicWorkRequest` (a repeating background task scheduled with WorkManager) is **15 minutes**. Even if you specify a shorter interval when building the `PeriodicWorkRequest`, WorkManager will enforce this 15-minute minimum for battery optimization reasons.

77. **How do you handle background tasks without draining battery?**
    The key is to use the right API for the right job, and respect system battery optimizations:

      * **Use WorkManager:** For *deferrable, guaranteed* background work. It leverages system APIs (JobScheduler, Doze) for efficient scheduling.
      * **Define Constraints:** For WorkManager tasks, specify constraints like `setRequiredNetworkType()`, `setRequiresCharging()`, `setRequiresDeviceIdle()` so tasks only run when conditions are optimal (e.g., on Wi-Fi and charging).
      * **Avoid unnecessary wakelocks:** If you use a wakelock, ensure it's held for the minimum duration required and released promptly.
      * **Short, Atomic Tasks:** Break down long tasks into smaller, manageable chunks.
      * **Foreground Services (only when necessary):** For user-facing, continuous tasks that cannot be interrupted, use foreground services with a persistent notification.
      * **Batching:** Group similar background tasks to reduce frequent device wake-ups.

78. **How would you detect user inactivity?**
    Detecting user inactivity typically involves monitoring user input events and setting a timer:

    1.  **Override `dispatchTouchEvent()` or `onUserInteraction()`:** In your base Activity, override `dispatchTouchEvent()` (to capture all touch events) or `onUserInteraction()` (a simpler callback for any user interaction).
    2.  **Reset a Timer/Handler:** Inside these methods, reset a `Handler.postDelayed()` timer. If the timer's runnable executes, it indicates a period of inactivity.
    3.  **Application.ActivityLifecycleCallbacks:** Observe lifecycle changes across all activities. If the app goes into the background for a prolonged period (no `onResume()` calls), it could indicate inactivity.
    4.  **`PowerManager.isInteractive()`:** (API 20+) Can check if the device is currently in an interactive state (screen on, user actively using it), though this is more about device state than specific app interaction.

79. **What is Doze mode and App Standby?**
    These are major battery optimization features introduced in Android 6.0 (Marshmallow):

      * **Doze mode:** This activates when a device is left stationary, unplugged, and with its screen off for an extended period. During Doze, the system periodically defers app background CPU, network activity, and syncs to brief "maintenance windows." This significantly reduces battery drain by extending the time between device wake-ups.
      * **App Standby:** This targets apps that the user hasn't actively used for a while. If an app isn't in the foreground and hasn't been used recently, it can be placed into an App Standby state. In this state, the system limits the app's network access and background jobs. It's designed to conserve battery for less frequently used apps.

80. **How does WorkManager differ from JobScheduler and AlarmManager?**

      * **`WorkManager`:** (High-level API) The recommended solution for *deferrable, guaranteed background work*. It handles persistence across reboots, network conditions, retries, and compatibility across Android versions by intelligently choosing the best underlying system APIs (`JobScheduler`, `AlarmManager`, `startService()`). Developers define "work," and WorkManager ensures it runs.
      * **`JobScheduler`:** (System API, API 21+) A lower-level API for *scheduling flexible, battery-efficient background jobs* based on specific conditions (network, charging, idle). It doesn't inherently offer persistence across reboots or fallbacks for older Android versions; WorkManager builds upon it.
      * **`AlarmManager`:** (System API) Used for *scheduling precise or inexact alarms* at specific times or intervals, even when the device is asleep or the app is not running. It's time-based, not condition-based, and doesn't inherently guarantee execution across reboots or manage battery optimizations as robustly as WorkManager. It's often used for one-time, time-critical events or repeating specific actions.

81. **What are Worker, ListenableWorker, and CoroutineWorker?**
    These are the abstract classes you extend to define the actual work that WorkManager executes:

      * **`Worker`:** The most basic abstract class for implementing *synchronous* background work. You override the `doWork()` method, which runs on a background thread managed by WorkManager, and return a `Result` (e.g., `Result.success()`, `Result.failure()`, `Result.retry()`).
      * **`ListenableWorker`:** An abstract class for performing *asynchronous* background work. You override `startWork()`, which returns a `ListenableFuture<Result>`. This allows you to initiate an asynchronous operation (like a network request) and signal its completion later by resolving the future. `Worker` is a synchronous implementation of `ListenableWorker`.
      * **`CoroutineWorker`:** A subclass of `ListenableWorker` that allows you to write your background work using Kotlin coroutines. You override `doWork()`, which is a `suspend` function. This provides a cleaner and more idiomatic way to handle asynchronous operations within WorkManager using Kotlin. It's the recommended choice when using Kotlin.

82. **How do you chain work requests in WorkManager?**
    WorkManager allows you to chain work requests to define a sequence or parallel execution of tasks:

      * **Sequential Chain:** To execute tasks in order (Task A then Task B then Task C):
        `WorkManager.getInstance(context).beginWith(workA).then(workB).then(workC).enqueue()`
      * **Parallel then Sequential:** To execute a set of tasks in parallel, and then another task after all of them complete:
        `WorkManager.getInstance(context).beginWith(listOf(workA, workB)).then(workC).enqueue()`
        WorkManager ensures that a work request in a chain only starts execution after all its predecessors in the chain have successfully completed. You can also define input for subsequent work requests based on the output of preceding ones.

## UI Components & Layouts

83. **What is the difference between View and ViewGroup?**
    \* **`View`:** The most basic building block of UI. It represents a single visual element on the screen that the user can see and interact with (e.g., `Button`, `TextView`, `ImageView`). It draws itself and handles events.
    \* **`ViewGroup`:** A special type of `View` that can contain (or "group") other `View`s and `ViewGroup`s. It's responsible for arranging its child views on the screen (e.g., `LinearLayout`, `RelativeLayout`, `ConstraintLayout`). It acts as a container for organizing UI elements.

84. **What is Toast in Android and how to display it?**
    A `Toast` is a small, transient, pop-up message that appears briefly on the screen and then automatically fades away. It's used to provide simple feedback to the user without interrupting their current activity.
    To display it:
    ` kotlin     Toast.makeText(context, "This is a Toast message!", Toast.LENGTH_SHORT).show()      `
    `context` is typically your `Activity` or `Application` context. `LENGTH_SHORT` or `LENGTH_LONG` determine duration.

85. **What is an Adapter and its purpose with RecyclerView?**
    An `Adapter` is a bridge between a data source (e.g., a list of items) and a UI component (like `RecyclerView` or `ListView`) that needs to display that data.
    With `RecyclerView`, the `Adapter`'s purpose is to:
    \* **Provide Data:** Retrieve data items from the data source.
    \* **Create ViewHolders:** Create and bind `ViewHolder`s (which hold references to item views) to display individual data items.
    \* **Bind Data to Views:** Populate the views within a `ViewHolder` with data for a specific position in the list.
    It efficiently manages the creation and recycling of item views as the user scrolls, improving performance.

86. **What are the differences between LinearLayout, RelativeLayout, and ConstraintLayout?**
    \* **`LinearLayout`:** Arranges views in a single row or column. Simple to use but can lead to deep, inefficient view hierarchies for complex UIs (nested weights).
    \* **`RelativeLayout`:** Arranges views based on their positions relative to each other (e.g., "to the right of," "below," "aligned with parent's top"). Can create flat hierarchies but often becomes complex and hard to maintain for intricate layouts.
    \* **`ConstraintLayout`:** A flexible and powerful layout that allows you to position and size views using "constraints" to other views, the parent, or guidelines. It's designed to create complex, flat, and highly optimized layouts, significantly reducing nested view hierarchies and improving performance. It's the recommended layout for most modern Android UIs.

87. **When might you use a FrameLayout?**
    You might use a `FrameLayout` when you need to display a single item or stack multiple items on top of each other, typically to display only one at a time.
    Common use cases:
    \* **Fragment Containers:** Often used as the container in an Activity where Fragments are added and replaced.
    \* **Overlays:** When you need to place a progress spinner, a badge, or a temporary message directly over another view.
    \* **Simple Views:** For very basic layouts that contain only one child view.

88. **Why is XML commonly used for Android UI layouts?**
    XML is commonly used for Android UI layouts because:
    \* **Separation of Concerns:** It cleanly separates the UI structure and design from the application's logic (Java/Kotlin code), making the code more organized and maintainable.
    \* **Readability and Declarative Nature:** XML is declarative, making layouts easy to read, understand, and visualize.
    \* **Static Layouts:** It's well-suited for defining static UI layouts.
    \* **Design Tools Integration:** Android Studio's Layout Editor provides excellent visual tools that work directly with XML layout files, enabling drag-and-drop design.
    \* **Resource Management:** XML layouts can easily leverage Android's resource system for different screen sizes, orientations, and languages.

89. **What are dp, sp, and px units? When to use each?**
    These are units of measurement for defining dimensions in Android layouts:
    \* **`px` (pixels):** Actual pixels on the screen. Device-dependent and not recommended for layouts as they don't scale across different screen densities. Use sparingly, usually for drawing specific pixel-perfect graphics.
    \* **`dp` (density-independent pixels):** A virtual pixel unit that scales with screen density. `1dp` is approximately `1/160th` of an inch. Use for defining UI element sizes (width, height, padding, margin) to ensure consistent physical size across devices with different pixel densities.
    \* **`sp` (scale-independent pixels):** Similar to `dp`, but also scales based on the user's font size preference. Use *only* for defining text sizes to ensure accessibility for users with impaired vision.

90. **What is a Spannable and SpannableString?**

      * **`Spannable`:** An interface that extends `CharSequence` and allows for applying markup objects (spans) to text at specific ranges. These spans can modify text appearance (e.g., bold, color, size), behavior (e.g., clickability), or even drawables, and can be changed even after creation.
      * **`SpannableString`:** A mutable implementation of the `Spannable` interface. It means you can apply, remove, and update spans on the text after it has been created.
        They are used when you need to display text with rich formatting where different parts of the text have different styles or behaviors (e.g., hyperlinked text, bold words in a sentence, text with custom fonts or background colors).

91. **What is View Binding vs Data Binding?**
    Both are tools to simplify interaction with views in Android:
    \* **`View Binding`:** A feature that generates a binding class for each XML layout file. This binding class contains direct references to all views in that layout that have an `id`. It replaces `findViewById()` calls, providing compile-time safety and type safety, preventing `NullPointerException`s due to missing views. It's generally faster and simpler to set up than Data Binding.
    \* **`Data Binding`:** A more powerful library that allows you to bind UI components in your layouts directly to data sources (e.g., `ViewModel`s, `LiveData`) using a declarative format in XML. This reduces boilerplate code for updating views, enables two-way data binding, and moves UI logic out of Activities/Fragments into the layout XML. It builds on top of View Binding.

92. **What is a Dialog and different types available?**
    A `Dialog` is a small pop-up window that appears in front of the current Activity, pausing the user's activity and requiring a response or acknowledgment before proceeding.
    Different types available:
    \* **`AlertDialog`:** The most common type, used for displaying simple messages with customizable buttons (positive, negative, neutral), title, and optionally an icon or list items.
    \* **`DatePickerDialog`:** For allowing users to select a date.
    \* **`TimePickerDialog`:** For allowing users to select a time.
    \* **`ProgressDialog` (Deprecated):** Used to show indeterminate progress (spinning circle) or determinate progress (progress bar). Replaced by custom `AlertDialog`s with `ProgressBar`s or other UI elements for better UX.
    \* **Custom Dialogs:** You can create your own dialogs by extending `DialogFragment` and inflating a custom layout, offering complete flexibility over the dialog's appearance and behavior.

93. **How do you create custom Views in Android?**
    You create custom `View`s in Android to encapsulate specific drawing and interaction logic, often to create unique UI components not provided by the standard framework.
    Steps typically involve:
    1\.  **Extend a `View` or `ViewGroup` subclass:** Choose the most appropriate base class (e.g., `View` for a custom drawing surface, `LinearLayout` for a composite view).
    2\.  **Override Constructors:** Implement the necessary constructors (typically `(Context context)`, `(Context context, AttributeSet attrs)`, `(Context context, AttributeSet attrs, int defStyleAttr)`).
    3\.  **Parse Custom Attributes (optional):** If you define custom attributes in `attrs.xml`, parse them in the constructor using `context.obtainStyledAttributes()`.
    4\.  **Override `onMeasure(int widthMeasureSpec, int heightMeasureSpec)`:** To determine the view's size.
    5\.  **Override `onDraw(Canvas canvas)`:** For custom drawing logic (if extending `View`). Use `Canvas` and `Paint` objects to draw shapes, text, images.
    6\.  **Handle Input Events:** Override `onTouchEvent(MotionEvent event)` for touch interactions or implement `OnClickListener`, etc.
    7\.  **Inflate Layout (if composite view):** If extending `ViewGroup` or a layout, you might inflate an XML layout into your custom view.

94. **What is RecyclerView and how does it improve upon ListView?**
    `RecyclerView` is a more advanced and flexible UI component for displaying large sets of data in a scrollable list or grid. It's designed to be highly efficient, especially for dynamic lists that change frequently.
    It improves upon `ListView` in several key ways:
    \* **Mandatory ViewHolder Pattern:** `RecyclerView` enforces the `ViewHolder` pattern, which optimizes performance by recycling views and avoiding expensive `findViewById()` calls during scrolling. `ListView` only recommended it.
    \* **LayoutManager:** `RecyclerView` decouples the responsibility of item positioning from the view itself, thanks to `LayoutManager`s (e.g., `LinearLayoutManager`, `GridLayoutManager`). This allows for easy switching between list, grid, and staggered layouts without changing the Adapter.
    \* **Item Animations:** `RecyclerView` provides built-in support for item animations (add, remove, move, change) through `ItemAnimator`, making list updates visually smoother. `ListView` had limited animation capabilities.
    \* **Modularity/Extensibility:** Its architecture is more modular, making it easier to customize various aspects (decoration, touch handling, item animations).

95. **How do you optimize RecyclerView performance?**
    Optimizing `RecyclerView` performance is crucial for smooth scrolling:
    \* **Use `ViewHolder` Pattern:** (Mandatory by design) Ensures views are recycled.
    \* **`DiffUtil`:** Use `DiffUtil` for list updates instead of `notifyDataSetChanged()` to calculate minimal updates, leading to smoother animations and better performance.
    \* **`setHasFixedSize(true)`:** If your `RecyclerView`'s height/width won't change based on content, call this to tell `RecyclerView` it doesn't need to recalculate item sizes on every scroll.
    \* **Avoid Expensive Operations in `onBindViewHolder()`:** Keep `onBindViewHolder()` lightweight. Avoid complex calculations, large allocations, or disk/network I/O. Defer these to background threads.
    \* **Optimize Item Layouts:** Keep item layouts flat and simple. Avoid deep nesting or complex `ViewGroup`s within item views. Use `ConstraintLayout`.
    \* **Pre-fetching:** For complex item layouts or images, consider using `RecyclerView.setItemViewCacheSize()` or `RecyclerView.setRecyclerListener()` to pre-load or pre-fetch items.
    \* **Lazy Loading Images:** Use image loading libraries (e.g., Glide, Coil) that support lazy loading and caching.
    \* **Stable IDs (`setHasStableIds(true)`):** If your data items have unique, unchanging IDs, set this to `true` and implement `getItemId()` in your adapter. This helps `RecyclerView` better track items during updates and animations.

96. **What are ViewHolders and their importance?**
    A `ViewHolder` is a simple container class that holds references to the `View`s for a single item in a `RecyclerView` list. Instead of calling `findViewById()` repeatedly for each new item, `RecyclerView` recycles `ViewHolder` objects.
    Their importance lies in:
    \* **Performance Optimization:** By holding cached references to item `View`s, `ViewHolder`s eliminate the need for expensive `findViewById()` calls during scrolling, greatly improving performance and smoothness.
    \* **Efficient Recycling:** When an item scrolls off-screen, its `ViewHolder` is detached and placed in a pool. When a new item scrolls into view, an existing `ViewHolder` from the pool is reused and simply re-bound with new data, rather than creating a whole new `View` hierarchy.
    \* **Structured Access:** Provides a clean way to access the child views of an item layout within the Adapter's `onBindViewHolder()` method.

97. **How do you handle item click events in RecyclerView?**
    Unlike `ListView`, `RecyclerView` does not have a built-in `setOnItemClickListener()`. You handle item click events by manually attaching click listeners to the views *within* the `ViewHolder` or the entire item view in the Adapter.
    Common approaches:
    1\.  **In `onBindViewHolder()`:** Set `OnClickListener` on the item's root view or individual child views. Pass the click event back to the Activity/Fragment via an interface or a lambda.

    ```kotlin
    class MyAdapter(...) {
        var onItemClick: ((MyItem) -> Unit)? = null

        override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
            val item = dataList[position]
            holder.itemView.setOnClickListener {
                onItemClick?.invoke(item)
            }
            // Or set on a specific view: holder.myButton.setOnClickListener { ... }
        }
    }
    // In Activity/Fragment:
    adapter.onItemClick = { item -> /* handle click for item */ }
    ```

<!-- end list -->

```
2.  **Using `View.OnClickListener` in `ViewHolder`:** Implement `OnClickListener` directly within the `ViewHolder` class. This is often cleaner.
3.  **Using the new `ListAdapter` and `DiffUtil`:** This combines well with `DiffUtil` for more robust state management and event handling.
```

98. **What is DiffUtil and how does it optimize RecyclerView updates?**
    `DiffUtil` is a utility class from the AndroidX support library that calculates the difference between two lists and outputs a list of update operations (additions, removals, moves, changes) that transform the old list into the new list.
    **How it optimizes updates:**
    \* **Granular Updates:** Instead of calling `notifyDataSetChanged()` (which redraws the entire list), `DiffUtil` allows you to call specific `RecyclerView.Adapter` methods like `notifyItemInserted()`, `notifyItemRemoved()`, `notifyItemChanged()`, etc.
    \* **Performance:** It performs the diff calculation on a background thread (or efficiently on the main thread for small lists) and then dispatches the updates to the adapter on the main thread.
    \* **Animations:** Granular updates enable `RecyclerView`'s default item animations to work correctly, providing a smoother user experience.
    \* **Efficiency:** It avoids unnecessary re-binding and re-drawing of items that haven't changed.

99. **What are the different RecyclerView LayoutManagers?**
    `LayoutManager` is an abstract class in `RecyclerView` that controls how items are positioned and laid out within the `RecyclerView`, as well as handling scrolling behavior.
    Common built-in `LayoutManager`s:

      * **`LinearLayoutManager`:** Lays out items in a single line, either vertically (most common for lists) or horizontally.
      * **`GridLayoutManager`:** Lays out items in a grid. You specify the number of columns (for vertical scrolling) or rows (for horizontal scrolling).
      * **`StaggeredGridLayoutManager`:** Lays out items in a staggered grid formation, allowing items of varying heights/widths to be placed without being clipped, creating a masonry-like effect.
        You can also create custom `LayoutManager`s for unique layout requirements.

100. **How do you implement pull-to-refresh functionality?**
     Pull-to-refresh functionality is typically implemented using the `SwipeRefreshLayout` widget from the AndroidX support library.
     Steps:
     1\.  **Wrap Content:** Wrap your scrollable content (`RecyclerView`, `ScrollView`, `NestedScrollView`, etc.) inside a `SwipeRefreshLayout` in your layout XML.

     ```xml
     <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
         android:id="@+id/swipeRefreshLayout"
         android:layout_width="match_parent"
         android:layout_height="match_parent">
         <androidx.recyclerview.widget.RecyclerView
             android:id="@+id/recyclerView"
             android:layout_width="match_parent"
             android:layout_height="match_parent" />
     </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
     ```

<!-- end list -->

````
2.  **Set Listener:** In your Activity/Fragment, get a reference to the `SwipeRefreshLayout` and set an `OnRefreshListener`.
    ```kotlin
    binding.swipeRefreshLayout.setOnRefreshListener {
        // Perform your data refresh operation (e.g., fetch new data from network)
        fetchNewData()
    }
    ```
3.  **Stop Refreshing:** Once your data refresh operation is complete (e.g., network call success/failure), you *must* call `swipeRefreshLayout.isRefreshing = false` to hide the refresh indicator.
    ```kotlin
    fun fetchNewData() {
        // ... (your async data fetching logic)
        // On completion:
        binding.swipeRefreshLayout.isRefreshing = false
    }
    ```
````

101. **What is CoordinatorLayout and its use cases?**
     `CoordinatorLayout` is a super-powered `FrameLayout` from the Material Design library. It's designed to orchestrate the interactions between its child views, enabling complex scrolling behaviors and visual effects (e.g., AppBarLayout reacting to scrolling, FloatingActionButton moving).
     **Use cases:**
     \* **Collapsing Toolbars/App Bars:** When you want a `Toolbar` to shrink or expand as the user scrolls.
     \* **Floating Action Buttons (FABs) with SnackBar:** Automatically moves the FAB up when a `SnackBar` appears.
     \* **Parallax Scrolling Effects:** Creating effects where background content scrolls at a different rate than foreground content.
     \* **Custom View Interactions:** Implementing custom interactions between any child views using `CoordinatorLayout.Behavior`.
     It achieves these effects by implementing a "behavior" system where child views can declare how they should interact with other child views or respond to scrolling events.

102. **How do you implement sliding panels and collapsing toolbars?**
     \* **Sliding Panels:** Typically implemented using `DrawerLayout` for navigation drawers (sliding from edge) or `BottomSheetBehavior` (from Material Design, for sliding from bottom of screen).

       * `DrawerLayout` hosts a main content view and a navigation view that slides over it.
       * `BottomSheetBehavior` can be applied to a child `View` within a `CoordinatorLayout` to make it behave as a persistent or modal bottom sheet.
         \* **Collapsing Toolbars:** Implemented using `CoordinatorLayout` in combination with `AppBarLayout` and `CollapsingToolbarLayout`.

     <!-- end list -->

     ```xml
     <androidx.coordinatorlayout.widget.CoordinatorLayout>
         <com.google.android.material.appbar.AppBarLayout>
             <com.google.android.material.appbar.CollapsingToolbarLayout
                 app:layout_scrollFlags="scroll|exitUntilCollapsed">
                 <ImageView app:layout_collapseMode="parallax" .../>
                 <androidx.appcompat.widget.Toolbar app:layout_collapseMode="pin" .../>
             </com.google.android.material.appbar.CollapsingToolbarLayout>
         </com.google.android.material.appbar.AppBarLayout>
         <androidx.core.widget.NestedScrollView app:layout_behavior="@string/appbar_scrolling_view_behavior">
             </androidx.core.widget.NestedScrollView>
     </androidx.coordinatorlayout.widget.CoordinatorLayout>
     ```

     `app:layout_scrollFlags` on `CollapsingToolbarLayout` and `app:layout_behavior` on the scrollable content are key.

103. **What are Motion Layouts and their advantages?**
     `MotionLayout` is a layout type in the AndroidX ConstraintLayout library that allows you to manage motion and widget animation in your app. It's a declarative way to define complex transitions between UI states (like expanding/collapsing elements, swipe-to-reveal) directly in XML.
     **Advantages:**
     \* **Simplified Complex Animations:** Enables creation of sophisticated animations that would be difficult or verbose with traditional animation APIs (Property Animators, etc.).
     \* **Declarative:** Define animations in XML, separating motion logic from code.
     \* **Interpolation and Keyframes:** Easily define various states (keyframes) and how views should animate between them.
     \* **Interaction Driven:** Animations can be driven by user input (e.g., swipe gestures) or programmatically.
     \* **Backward Compatibility:** Works down to API 14.
     \* **Visual Editor:** Android Studio's Motion Editor provides a visual tool to design these animations.

104. **How do you handle different screen sizes and orientations?**
     Handling different screen sizes and orientations involves providing alternative resources and using flexible layouts:
     \* **`dp` and `sp` units:** Always use `dp` for dimensions and `sp` for text sizes for density independence.
     \* **Flexible Layouts:** Use `ConstraintLayout` or `FlexboxLayout` (third-party) which can adapt dynamically to available space. Avoid hardcoded `px` values.
     \* **Resource Qualifiers:** Provide alternative layout, dimension, drawable, or string resources using qualifiers based on screen size (`sw600dp` for 600dp minimum width), orientation (`land` for landscape, `port` for portrait), screen density (`hdpi`, `xhdpi`), or smallest width (`w600dp`).

       * `res/layout/my_layout.xml` (default)
       * `res/layout-land/my_layout.xml` (for landscape)
       * `res/layout-sw600dp/my_layout.xml` (for tablets/large screens)
         \* **`Fragment`s:** Use Fragments to encapsulate UI parts that can be combined differently on larger screens (e.g., master-detail flow).
         \* **`Configuration Changes`:** Understand how Activities handle configuration changes (recreation by default). Use `ViewModel` or `onSaveInstanceState()` to preserve UI state.

## Data Storage & Persistence

105. **What are different ways to store data in Android?**
     Android offers several options for data storage, each suited for different needs:
     \* **`SharedPreferences`:** For storing small amounts of private primitive data (key-value pairs).
     \* **Internal Storage:** For storing private application data directly on the device's internal memory. Files are typically only accessible by the app itself.
     \* **External Storage:** For storing larger files that are intended to be shared or accessible by other apps (e.g., public photos, downloads). Requires permissions.
     \* **SQLite Databases:** For storing structured, private data in a relational database. Ideal for complex data relationships.
     \* **Room Persistence Library:** An abstraction layer over SQLite that simplifies database interactions, part of Android Jetpack.
     \* **`DataStore`:** A modern replacement for `SharedPreferences`, offering asynchronous and type-safe data storage using Kotlin Flow and Protocol Buffers (for `Proto DataStore`).
     \* **Network Storage/Cloud:** Storing data on remote servers (e.g., Firebase, custom backend) for synchronization, backups, and multi-device access.

106. **What is SharedPreferences and its pros and cons?**
     `SharedPreferences` is an API in Android used for storing small collections of primitive data (booleans, floats, ints, longs, strings) as key-value pairs. It's suitable for app settings, user preferences, or simple state.
     \* **Pros:**

       * Simple to use for small amounts of data.
       * Fast for reading and writing primitive types.
       * Data persists across app sessions.
       * Private to the application by default.
         \* **Cons:**
       * Not designed for complex data or large datasets.
       * Not thread-safe (can lead to ANRs if misused on main thread).
       * Synchronous API calls on the main thread can cause UI jank.
       * No type safety without manual casting/handling.
       * No support for migrations or schema changes.
       * Not suitable for sensitive data without encryption (use EncryptedSharedPreferences).

107. **What is the difference between commit() and apply() in SharedPreferences?**
     Both `commit()` and `apply()` save changes to `SharedPreferences`, but they differ in how they perform the write operation:
     \* **`commit()`:** Writes the preferences **synchronously** to disk. It blocks the calling thread until the write is complete and returns a boolean indicating success or failure. If called on the main thread, it can cause ANRs (Application Not Responding) if the disk operation is slow.
     \* **`apply()`:** Writes the preferences **asynchronously** to disk. It returns immediately, allowing the calling thread (including the main thread) to continue without blocking. It does not return a boolean indicating success or failure. The write happens in the background. This is generally the preferred method for most use cases to avoid blocking the UI.

108. **What is SQLite and how is it used in Android?**
     SQLite is an open-source, lightweight, embedded relational database management system. It's a self-contained, serverless, zero-configuration, transactional SQL database engine.
     In Android, SQLite is used for storing structured, private application data persistently on the device. Developers interact with it using:
     \* **`SQLiteOpenHelper`:** A helper class to manage database creation and version management.
     \* **`SQLiteDatabase`:** The class representing the SQLite database, through which you execute SQL queries directly (e.g., `insert()`, `query()`, `update()`, `delete()`, `execSQL()`).
     While `SQLiteDatabase` provides low-level control, for modern Android development, the Room Persistence Library (which builds on SQLite) is strongly preferred for its simplicity and robustness.

109. **What is Room Persistence Library and why is it preferred?**
     Room Persistence Library is part of Android Jetpack's Architecture Components. It's an abstraction layer over SQLite, providing an object-mapping layer that greatly simplifies database interactions in Android apps.
     **Why it's preferred:**
     \* **Compile-time SQL Validation:** Room validates your SQL queries at compile time, catching errors early.
     \* **Reduced Boilerplate:** It generates a lot of the boilerplate code needed for database interaction (e.g., SQL queries, cursor conversions).
     \* **Type Safety:** Works with Kotlin/Java objects, reducing manual type conversions and potential runtime errors.
     \* **Observable Queries:** Integrates seamlessly with `LiveData` or Kotlin Flow, allowing your UI to react to database changes in real-time.
     \* **Asynchronous Support:** Provides built-in support for running database operations on background threads, preventing ANRs.
     \* **Easier Migrations:** Simplifies database schema migrations.

110. **How can you encrypt data in Android applications?**
     Encrypting data in Android applications is crucial for sensitive information. Methods include:
     \* **`EncryptedSharedPreferences`:** (Jetpack Security) For encrypting key-value pairs, built on top of `SharedPreferences`. Recommended for small, sensitive data like API keys, tokens.
     \* **AndroidX Security Crypto Library:** Provides low-level cryptographic primitives (e.g., `MasterKey` generation, `FileEncryptionHelper`) for encrypting files or streams.
     \* **SQLCipher for Android (Third-party):** A popular open-source extension to SQLite that provides full database encryption.
     \* **Keystore System:** The Android Keystore system securely stores cryptographic keys (public/private keys, symmetric keys) in a hardware-backed keystore, making them resistant to extraction and protecting them from malware. Keys stored here are used to encrypt/decrypt application data.
     \* **Manual Encryption:** Using standard Java Cryptography Architecture (JCA) APIs like `Cipher` and `MessageDigest`, but this requires careful implementation to avoid common cryptographic pitfalls. Generally, using higher-level libraries is safer.

111. **How does Room handle database migrations?**
     Room handles database migrations by requiring you to define `Migration` classes. A `Migration` class specifies the necessary SQL commands to transform the database schema from one version to another.
     1\.  **Define `Migration`:** Create a `Migration` object for each version upgrade path, providing the `startVersion` and `endVersion` and implementing the `migrate(SupportSQLiteDatabase database)` method with SQL `ALTER TABLE`, `CREATE TABLE`, `DROP TABLE` statements.
     2\.  **Add to Database Builder:** Provide these `Migration` objects to your `Room.databaseBuilder()` call:
     `Room.databaseBuilder(context, AppDatabase::class.java, "my-db").addMigrations(MIGRATION_1_2, MIGRATION_2_3).build()`
     Room then automatically applies the correct migrations when the database version changes. If a migration path is not provided and the schema changes, Room will throw an `IllegalStateException` or simply clear the database (if `fallbackToDestructiveMigration()` is used).

112. **How do you manage relationships in Room?**
     Room supports managing relationships (one-to-one, one-to-many, many-to-many) between entities, but unlike some ORMs, it **does not directly support object references** between entities. Instead, you manage relationships by:
     \* **Foreign Keys:** Define foreign key constraints using the `foreignKeys` array in the `@Entity` annotation to enforce referential integrity between tables.
     \* **Embedded Objects (`@Embedded`):** To represent a complex object that is part of an entity but doesn't have its own table.
     \* **POJOs (Plain Old Java Objects) with `@Relation`:** To query data across relationships, you define a POJO that contains the parent entity and a list of child entities (or a single child entity). You annotate fields in this POJO with `@Relation` to specify the `parentColumn`, `entityColumn`, and optionally `associateBy` (for many-to-many). Room then generates the join queries for you.
     \* **Manual Joins:** You can still write custom SQL queries with `JOIN` clauses in your DAO methods if `@Relation` doesn't fit your needs.

113. **What is DAO (Data Access Object) in Room?**
     A DAO (Data Access Object) in Room is an interface or abstract class that provides methods for interacting with your database. It's the primary component through which you define your database queries and operations.
     **Key characteristics:**
     \* **Abstracts SQL:** You don't write raw SQL for common operations like insert, update, delete. Instead, you annotate methods with `@Insert`, `@Update`, `@Delete`.
     \* **Custom Queries:** For complex queries, you use the `@Query` annotation and write SQL (Room validates it at compile time).
     \* **Return Types:** DAO methods can return simple data, `LiveData`, or `Flow` for reactive updates.
     \* **One DAO per Entity (or related entities):** Typically, you create one DAO per major entity or for a group of closely related entities.
     Room automatically generates the implementation of the DAO interface/abstract class at compile time.

114. **Explain Scoped Storage in Android and its implications.**
     Scoped Storage is a privacy-enhancing feature introduced in Android 10 (API 29) and enforced in Android 11 (API 30) onwards. It restricts an app's access to the device's external storage.
     **Implications:**
     \* **App-specific Directories:** Apps are primarily granted access only to their own app-specific directory on external storage (`getExternalFilesDir()`, `getExternalCacheDir()`). These directories are removed when the app is uninstalled.
     \* **MediaStore for Shared Media:** To access shared media files (images, videos, audio) belonging to *other* apps or created by the user (e.g., camera photos), apps must use the `MediaStore` API. `MediaStore` provides a content URI for each media file, allowing apps to read or write specific files with user consent.
     \* **Downloads/Documents:** For non-media files (e.g., PDFs, documents) in the "Downloads" or "Documents" folder, apps must use the `Storage Access Framework (SAF)` to let the user select files for the app to access.
     \* **Limited Direct Access:** Direct file path access to common public directories (like `Pictures`, `DCIM`) is largely restricted without explicit user selection.
     \* **Legacy Mode (`requestLegacyExternalStorage`):** Android 10 offered a temporary opt-out via `requestLegacyExternalStorage="true"` for compatibility, but this was removed in Android 11.

115. **How can encrypted SharedPreferences be used?**
     `EncryptedSharedPreferences` is a secure implementation of `SharedPreferences` provided by the Android Jetpack Security library. It automatically encrypts keys and values using the Android Keystore system.
     **How to use it:**
     1\.  **Setup Keystore Master Key:** First, create a `MasterKey` that will be used for encryption. This key is securely stored in the Android Keystore.

     ```kotlin
     val masterKey = MasterKey.Builder(context)
         .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
         .build()
     ```

<!-- end list -->

````
2.  **Create EncryptedSharedPreferences:** Use `EncryptedSharedPreferences.create()` to get an instance, passing the `MasterKey` and a file name.
    ```kotlin
    val sharedPreferences = EncryptedSharedPreferences.create(
        context,
        "my_encrypted_prefs", // Filename
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    ```
3.  **Use Like Regular SharedPreferences:** Once created, you use the `sharedPreferences` instance exactly like regular `SharedPreferences` to put and get values. The encryption/decryption happens automatically under the hood.
````

116. **What is DataStore and how does it compare to SharedPreferences?**
     `DataStore` is a new and improved data storage solution from Android Jetpack, designed to replace `SharedPreferences`. It provides a safe, asynchronous, and consistent way to store data.
     **Key Differences/Comparison:**
     | Feature            | SharedPreferences                                 | DataStore                                       |
     | :----------------- | :------------------------------------------------ | :---------------------------------------------- |
     | **API Type** | Synchronous (commit), Asynchronous (apply)        | Fully Asynchronous (Kotlin Flow, Coroutines)    |
     | **Thread Safety** | Not inherently thread-safe (can cause ANR with commit) | Thread-safe by design                             |
     | **Safety** | No compile-time type safety; runtime errors possible | Type-safe (Proto DataStore)                     |
     | **Data Type** | Primitives (Boolean, Int, String, etc.)           | Primitives (Preferences DataStore), Custom types (Proto DataStore) |
     | **Error Handling** | No direct error handling with apply               | Built-in error handling (Flow's catch)          |
     | **Consistency** | No transactional API, inconsistent state possible | Transactional API, atomic updates               |
     | **Usage** | Simple key-value pairs                            | Key-value pairs (Preferences DS), structured objects (Proto DS) |
     | **Encryption** | Requires `EncryptedSharedPreferences`             | Supports encryption (via `Security` library)    |
     **Conclusion:** `DataStore` is the recommended modern solution due to its asynchronous nature, thread safety, and consistency, especially when using Kotlin Coroutines and Flow.

117. **What are best practices for storing application data securely?**
     \* **Use `EncryptedSharedPreferences`:** For small, sensitive key-value pairs (e.g., user tokens, API keys).
     \* **Use AndroidX Security Crypto Library:** For encrypting files or streams with keys from the Android Keystore.
     \* **Utilize Android Keystore System:** For securely storing cryptographic keys, protecting them from unauthorized access or extraction.
     \* **Avoid storing sensitive data on external storage:** External storage (`Environment.getExternalStorageDirectory()`) is world-readable/writable. Use internal storage or encrypted external storage if necessary.
     \* **Encrypt databases:** If using SQLite, consider libraries like SQLCipher for full database encryption.
     \* **Do not hardcode sensitive data:** Avoid embedding API keys, secrets directly in your code. Use build configurations or retrieve them from secure backend services.
     \* **Use HTTPS/TLS for network communication:** Encrypt data in transit.
     \* **Implement proper authentication and authorization:** On the server side.
     \* **Minimize data storage:** Only store what's absolutely necessary.
     \* **Obfuscation/ProGuard/R8:** While not encryption, these tools make reverse engineering harder.

118. **Can you access SQLite database for debugging?**
     Yes, you can access your app's SQLite database for debugging purposes.
     Common methods:
     \* **Device File Explorer in Android Studio:** Navigate to `data/data/<your-package-name>/databases/` to download the `.db` file. You can then open it with a desktop SQLite browser (e.g., DB Browser for SQLite).
     \* **App Inspection in Android Studio:** (Recommended for Room) This built-in tool in Android Studio allows you to inspect, query, and modify your Room databases and `SharedPreferences` in real-time while your app is running on an emulator or a connected device. This is the most convenient method.
     \* **ADB commands:** Use `adb shell` to navigate to the database directory and `adb pull` to copy the database file to your local machine.

119. **How do you handle database versioning and schema changes?**
     Database versioning and schema changes (migrations) are handled by incrementing the database version number and providing migration paths.
     \* **Increment Version:** In your `RoomDatabase` annotation, increment `version = X+1`.
     \* **Create `Migration` classes:** For each version upgrade path (e.g., from version 1 to 2, 2 to 3), create a `Migration` object that contains the SQL statements (`ALTER TABLE`, `CREATE TABLE`, `DROP TABLE`) needed to transform the schema from the old version to the new one.
     \* **Add Migrations to Builder:** Provide these `Migration` objects to your `Room.databaseBuilder()` instance:
     `Room.databaseBuilder(...).addMigrations(MIGRATION_1_2, MIGRATION_2_3).build()`
     \* **Destructive Migration:** If a migration path is not available or you want to wipe existing data on schema change (e.g., during development), you can use `fallbackToDestructiveMigration()` in the builder. This will rebuild the database from scratch, deleting all existing data.

120. **What is Content Resolver and its role in data access?**
     A `ContentResolver` is a class in Android that provides an abstraction layer for accessing data from a `ContentProvider`. It acts as a client-side interface to perform "CRUD" (Create, Read, Update, Delete) operations on data managed by Content Providers.
     **Its role in data access:**
     \* **Centralized Access:** It's the standard way for applications to interact with data that is exposed by `ContentProvider`s, regardless of where that data is actually stored (e.g., SQLite database, files, network).
     \* **Inter-App Communication:** It enables secure and controlled sharing of data between different applications. For example, an app can use `ContentResolver` to query the Contacts provider to read user contacts.
     \* **Security:** `ContentProvider`s can enforce permissions, and `ContentResolver` mediates access, ensuring only authorized apps can access specific data.
     \* **Abstraction:** It abstracts the underlying storage mechanism, so clients don't need to know if the data is in SQLite, a file, or a network service.

## Asynchronous Programming & Concurrency

121. **Why should long-running operations not be performed on main thread?**
     Long-running operations (e.g., network requests, heavy database queries, complex calculations, file I/O) should **never** be performed on the main thread (also known as the UI thread) because:
     \* **ANR (Application Not Responding):** If the main thread is blocked for too long (typically more than 5 seconds), the system will display an "Application Not Responding" dialog, giving the user the option to close your app.
     \* **Unresponsive UI:** While the main thread is busy, the UI becomes frozen. The user cannot interact with buttons, scroll, or see animations, leading to a poor user experience.
     \* **Jank/Stuttering:** Even shorter blocking operations can cause visible jank (skipped frames) in animations and scrolling, making the app feel sluggish.
     The main thread is responsible for drawing the UI and handling user input, so it must remain free to respond quickly.

122. **What is ANR (Application Not Responding) and how to avoid it?**
     An ANR (Application Not Responding) is a dialog that Android displays to the user when an application has been unresponsive for a significant period. This happens when the main thread (UI thread) is blocked and cannot process user input or draw the UI within a certain timeframe (typically 5 seconds for input events or broadcast receiver execution).
     **How to avoid it:**
     \* **Perform all long-running operations on background threads:** Use Kotlin Coroutines, WorkManager, Executors, or Services for network requests, database operations, heavy computations, and large file I/O.
     \* **Keep main thread lightweight:** Ensure UI updates are minimal and quick.
     \* **Optimize UI drawing:** Avoid complex or nested view hierarchies that take too long to measure and draw.
     \* **Avoid heavy operations in Activity/Fragment lifecycle methods:** Especially `onCreate()`, `onResume()`.
     \* **Use `StrictMode` for debugging:** During development, `StrictMode` can help detect accidental disk or network access on the main thread.

123. **What is a Thread in Android and how does it differ from Process?**
     \* **`Thread`:** A single sequential flow of control within a program. It's a lightweight unit of execution that shares the same memory space and resources (e.g., heap, open files) as other threads within the same process. An Android application typically starts with a single main thread (UI thread) but can create additional background threads for concurrent operations.
     \* **`Process`:** An isolated execution environment that has its own virtual memory space, resources, and typically runs independently. In Android, each application runs in its own Linux process by default, providing security and isolation. If one process crashes, it generally doesn't affect other processes. A process can contain one or more threads.

124. **How do you perform background operations in Android?**
     Several modern and traditional ways to perform background operations in Android:
     \* **Kotlin Coroutines (Recommended for modern Android):** Lightweight threads, excellent for asynchronous programming, managing concurrency, and handling long-running tasks.
     \* **`WorkManager` (Recommended for deferrable, guaranteed work):** For tasks that need to run reliably even if the app exits or device restarts (e.g., data sync, uploading logs).
     \* **`Service`:** For operations that need to run continuously in the background independent of the UI (e.g., music playback). Requires managing your own threads inside.
     \* **`Executors` / `ThreadPoolExecutor`:** Standard Java concurrency utilities for managing pools of threads.
     \* **`HandlerThread`:** A special type of Thread that has its own Looper and MessageQueue, useful for background work that requires sequential processing of messages.
     \* **`AsyncTask` (Deprecated):** Older, simpler API for short-lived background tasks with UI updates, but prone to memory leaks and lifecycle issues. Avoid using it.

125. **What are Kotlin Coroutines and their advantages?**
     Kotlin Coroutines are a concurrency design pattern that allows you to write asynchronous, non-blocking code in a sequential and more readable manner. They are "lightweight threads" managed by the system, not the OS.
     **Advantages:**
     \* **Asynchronous Code Simplicity:** Transform complex callback-based or reactive code into sequential-looking code using `suspend` functions, making it much easier to read and maintain.
     \* **Lightweight:** Coroutines are much lighter than threads. You can launch thousands of coroutines on a single thread.
     \* **Structured Concurrency:** They promote structured concurrency, meaning coroutines launched within a scope are cancelled when the scope is cancelled, preventing resource leaks and ensuring all operations are completed or cancelled predictably.
     \* **Non-blocking:** `suspend` functions don't block the underlying thread; they simply pause execution and resume later, freeing up the thread for other tasks.
     \* **First-Party Support:** Integrated into Kotlin, with strong support in Android Jetpack libraries (`LifecycleScope`, `ViewModelScope`).

126. **Explain the `suspend` keyword in Kotlin Coroutines.**
     The `suspend` keyword in Kotlin Coroutines is a modifier that marks a function as "suspendable," meaning it can be *paused* and *resumed* later.
     \* It does **not** mean the function will run on a different thread. A `suspend` function can run on any thread.
     \* It signifies that the function might perform a long-running operation (like a network request, database call, or delay) that could potentially block the current thread if it were a regular function.
     \* When a `suspend` function is called, it can pause its execution without blocking the thread it's running on, allowing the thread to perform other tasks. When the long-running operation completes, the `suspend` function can *resume* from where it left off.
     \* `suspend` functions can only be called from other `suspend` functions or from a coroutine builder (like `launch` or `async`).

127. **What is a CoroutineScope and why is it important?**
     A `CoroutineScope` defines the lifecycle of coroutines. It's a way to group related coroutines, allowing you to manage their lifecycle collectively.
     **Importance:**
     \* **Structured Concurrency:** Ensures that all coroutines launched within a `CoroutineScope` are cancelled when the scope itself is cancelled. This prevents leaks (e.g., a coroutine continuing to run and update a UI that no longer exists) and ensures that all work for a given unit (like a `ViewModel` or `Activity`) is completed or stopped when that unit is destroyed.
     \* **Resource Management:** Helps in cleaning up resources associated with coroutines when they are no longer needed.
     \* **Common Scopes:** Android Jetpack provides built-in `CoroutineScope`s like `LifecycleScope` (scoped to Activity/Fragment lifecycle) and `ViewModelScope` (scoped to ViewModel lifecycle), making it easy to integrate coroutines with Android components.

128. **What is the difference between `launch` and `async`?**
     Both `launch` and `async` are coroutine builders used to start a new coroutine.
     \* **`launch`:**

       * Used to start a new coroutine that does not return a result.
       * It's a "fire and forget" operation. If the coroutine throws an exception, it will propagate and potentially crash the application if not handled by a `CoroutineExceptionHandler`.
       * Returns a `Job` object, which can be used to cancel or join the coroutine.
       * **Use when:** You need to perform background work, but you don't need to get a result back from it immediately.
         \* **`async`:**
       * Used to start a new coroutine that performs work and returns a result.
       * It returns a `Deferred<T>` object (a non-blocking future). You call `.await()` on the `Deferred` object to get the result.
       * Exceptions are propagated when `.await()` is called. If `.await()` is never called, the exception won't be thrown until the `Deferred` is garbage collected.
       * **Use when:** You need to perform background work and then use the result of that work.

129. **What are Dispatchers (Main, IO, Default, Unconfined)?**
     `Dispatchers` determine which thread or thread pool a coroutine will use for its execution.
     \* **`Dispatchers.Main`:** The main thread (UI thread). Use for interacting with the UI and performing fast operations.

       * **Example:** `lifecycleScope.launch(Dispatchers.Main) { updateUI(data) }`
         \* **`Dispatchers.IO`:** A thread pool optimized for disk and network I/O operations.
       * **Example:** `withContext(Dispatchers.IO) { database.insert(item) }`
         \* **`Dispatchers.Default`:** A shared thread pool designed for CPU-intensive work that blocks the current thread (e.g., sorting large lists, complex calculations).
       * **Example:** `withContext(Dispatchers.Default) { performHeavyCalculation() }`
         \* **`Dispatchers.Unconfined`:** Runs the coroutine on the caller's thread initially. It only dispatches on a different thread when the coroutine encounters a suspension point. Not typically recommended for general use in Android due to its unpredictable thread switching, making it harder to reason about.

130. **Explain Handler, Looper, and MessageQueue relationship.**
     These three components form the backbone of Android's UI message processing system:
     \* **`Looper`:** A class that continuously loops (hence "looper") through a `MessageQueue` and dispatches `Message`s and `Runnable`s to their corresponding `Handler`s. Every thread that wants to participate in the message passing system (like the main thread) needs a `Looper`.
     \* **`MessageQueue`:** A queue that holds the list of `Message`s and `Runnable`s to be processed by a `Looper`. `Handler`s post messages to this queue.
     \* **`Handler`:** An object that allows you to send and process `Message`s and `Runnable`s associated with a specific `Looper`'s `MessageQueue`. It enables communication between threads, allowing background threads to post tasks to the main thread's `Handler` to update the UI safely.

131. **What is a HandlerThread and when is it useful?**
     A `HandlerThread` is a convenience class that is essentially a `Thread` that has its own `Looper` and `MessageQueue` set up within it.
     **When it's useful:**
     \* When you need a background thread to perform operations sequentially.
     \* When you need to send messages or runnables to a specific background thread in a controlled manner.
     \* For tasks that need to run continuously in the background but are not suitable for `WorkManager` (e.g., a background service that continuously monitors a sensor and processes events sequentially).
     It allows you to perform background work while receiving callbacks on that specific background thread, rather than the main thread.

132. **How does Garbage Collector work in Android?**
     Android uses a garbage collector (GC) to automatically reclaim memory used by objects that are no longer referenced by the application. ART (Android Runtime) uses a Concurrent Copying Garbage Collector.
     **How it generally works:**
     1\.  **Marking:** The GC identifies all objects that are still reachable (in use) by the application (starting from root references like static variables, active threads).
     2\.  **Sweeping/Compacting:** It then reclaims memory occupied by unreachable (unused) objects. Modern GCs also perform "compaction" to move live objects closer together, reducing memory fragmentation.
     3\.  **Concurrency:** ART's GC is largely "concurrent," meaning a significant portion of the garbage collection work runs in parallel with the application threads. This minimizes the "stop-the-world" (STW) pauses, which are periods where all app threads are temporarily frozen for GC, leading to smoother UI performance.
     Efficient memory management and avoiding memory leaks are crucial to reduce GC pressure.

133. **What is the onTrimMemory() method?**
     The `onTrimMemory()` callback method is part of the `ComponentCallbacks2` interface, which is implemented by `Application`, `Activity`, and `Service`. It's a system callback that indicates that the operating system is running low on memory and is asking your application to release non-critical resources to help manage memory.
     The method receives a `level` argument that indicates the severity of the memory pressure:
     \* `TRIM_MEMORY_RUNNING_CRITICAL`, `TRIM_MEMORY_RUNNING_LOW`, `TRIM_MEMORY_RUNNING_MODERATE`: Indicate the app is running, but memory is getting tight.
     \* `TRIM_MEMORY_BACKGROUND`, `TRIM_MEMORY_MODERATE`, `TRIM_MEMORY_COMPLETE`: Indicate the app is in the background and might be killed.
     Responding to `onTrimMemory()` allows your app to gracefully release memory and reduce its likelihood of being killed by the system, improving user experience.

134. **Can you manually call Garbage Collection?**
     You can *suggest* to the Java Virtual Machine (JVM) or Android Runtime (ART) that it should run garbage collection by calling `System.gc()` or `Runtime.getRuntime().gc()`.
     However, it's crucial to understand:
     \* **It's only a suggestion:** The system is not *guaranteed* to run GC immediately. It will do so only if it deems it necessary.
     \* **Not recommended in production code:** Manually calling GC is generally discouraged in production Android applications. It can be inefficient, disrupt the runtime's own memory management, and potentially cause jank.
     \* **Use for Debugging/Testing:** It can be useful in specific debugging scenarios (e.g., after forcing a memory leak cleanup in tests) to verify memory reclamation.
     The best practice is to focus on avoiding memory leaks and writing efficient code that minimizes memory allocations, allowing the automatic GC to manage memory effectively.

135. **Explain "structured concurrency" in Kotlin Coroutines.**
     Structured concurrency is a design principle in Kotlin Coroutines that ensures that all coroutines launched within a specific `CoroutineScope` are automatically cancelled when that `scope` is cancelled. This means:
     \* **Parent-Child Relationship:** When you launch a new coroutine, it becomes a child of the `CoroutineScope` it was launched in.
     \* **Automatic Propagation:** Cancellation flows downwards from parent to children. If a parent `Job` (part of the `CoroutineScope`) is cancelled, all its child coroutines are also cancelled.
     \* **Error Handling:** Errors in child coroutines are propagated up to the parent `Job`, which can then cancel other children in the same scope.
     \* **Resource Safety:** It helps prevent resource leaks by ensuring that all ongoing asynchronous operations tied to a specific lifecycle (e.g., an Activity or `ViewModel`) are properly cleaned up when that lifecycle ends. This simplifies error handling and prevents subtle bugs.

136. **What is the difference between Thread and Coroutine?**
     | Feature         | Thread                                            | Coroutine                                         |
     | :-------------- | :------------------------------------------------ | :------------------------------------------------ |
     | **Cost** | Heavyweight (managed by OS)                       | Lightweight (managed by the Coroutine library/runtime) |
     | **Blocking** | Blocks the OS thread it runs on                   | Non-blocking (suspends and resumes)               |
     | **Creation** | Expensive                                         | Cheap (can create thousands)                      |
     | **Stack Size** | Fixed, relatively large stack                     | Small, flexible stack                             |
     | **Management** | Manual management (start, stop, join, synchronize) | Managed by CoroutineScope, automatic cancellation |
     | **Concurrency** | Achieved by running multiple threads concurrently | Achieved by suspending and resuming execution on a few threads |
     \* **Threads** are actual operating system entities that run in parallel.
     \* **Coroutines** are a higher-level abstraction for concurrency. They are cooperative; they allow multiple execution flows to run on a limited number of underlying threads by suspending and resuming.

137. **What are race conditions and deadlocks? How to prevent them?**
     These are common concurrency issues:
     \* **Race Condition:** Occurs when two or more threads try to access and modify the same shared resource (e.g., a variable, a database entry, a file) concurrently, and the final outcome depends on the non-deterministic order in which the threads execute. This can lead to incorrect or unpredictable results.

       * **Prevention:**
           * **Synchronization:** Use `synchronized` blocks/methods, `ReentrantLock`, `Mutex` (in coroutines) to ensure only one thread accesses the critical section at a time.
           * **Atomic Operations:** Use atomic classes (e.g., `AtomicInteger`) for single-variable updates.
           * **Immutability:** Make shared data immutable.
           * **Thread-safe Collections:** Use collections like `ConcurrentHashMap`.
             \* **Deadlock:** A situation where two or more threads are permanently blocked, waiting for each other to release a resource. Each thread holds a resource that another thread needs, forming a circular dependency.
       * **Prevention (avoiding the four conditions for deadlock):**
           * **Mutual Exclusion (avoid when possible):** If a resource can be shared without exclusive access, do so.
           * **Hold and Wait (prevent):** Don't allow a thread to hold one resource while waiting for another. Acquire all needed resources at once or release held ones if acquisition fails.
           * **No Preemption (prevent):** Allow a resource to be forcibly taken from a thread holding it (if practical).
           * **Circular Wait (break):** Establish a strict ordering for acquiring resources. All threads acquire resources in the same predefined order.

138. **What are synchronization mechanisms available?**
     Synchronization mechanisms ensure that only one thread can access a shared resource or a critical section of code at a time, preventing race conditions.
     \* **`synchronized` keyword:** In Java/Kotlin, a built-in mechanism for locking methods or code blocks.

       * `synchronized fun myMethod() { ... }` (locks on the object instance)
       * `synchronized(lockObject) { ... }` (locks on the specified object)
         \* **`java.util.concurrent.locks.Lock` interface (e.g., `ReentrantLock`):** More flexible and powerful than `synchronized` blocks, offering features like tryLock(), fairness, and condition variables.
         \* **`java.util.concurrent.Semaphore`:** Controls access to a limited number of resources.
         \* **`java.util.concurrent.atomic` package:** Classes like `AtomicInteger`, `AtomicLong`, `AtomicReference` provide atomic (thread-safe) operations on single variables without explicit locks.
         \* **`Mutex` (in Kotlin Coroutines):** A mutual exclusion mechanism for coroutines, similar to a lock but designed for non-blocking suspension.
         \* **Thread-safe Collections:** Collections like `ConcurrentHashMap`, `CopyOnWriteArrayList` are designed for concurrent access.

139. **What is a Thread Pool and its benefits?**
     A `ThreadPool` is a collection of worker threads that are created in advance and kept ready to execute tasks. Instead of creating a new thread for each task, tasks are submitted to the thread pool, which then assigns them to an available thread from its pool.
     **Benefits:**
     \* **Reduced Overhead:** Avoids the overhead of repeatedly creating and destroying threads, which are expensive operations.
     \* **Improved Performance:** Tasks can be executed more quickly as threads are already running.
     \* **Resource Management:** Limits the number of concurrent threads, preventing the system from being overwhelmed by too many active threads, which can lead to performance degradation or crashes.
     \* **Queueing:** If all threads in the pool are busy, new tasks are placed in a queue and executed when a thread becomes available.
     \* **Reusability:** Threads are reused across multiple tasks.
     Commonly implemented using `java.util.concurrent.Executors` (e.g., `newFixedThreadPool`, `newCachedThreadPool`).

140. **How do you ensure thread safety in Android?**
     Ensuring thread safety means designing code such that shared data remains consistent even when accessed and modified by multiple threads concurrently.
     Key strategies:
     \* **Avoid Shared Mutable State:** The simplest way is to design your architecture to minimize or eliminate shared mutable state.
     \* **Immutability:** Make data objects immutable. If data cannot be changed after creation, it's inherently thread-safe.
     \* **Synchronization:** Use `synchronized` blocks/methods, `Lock` objects (`ReentrantLock`), or `Mutex` (Coroutines) to protect critical sections of code that access shared mutable resources.
     \* **Atomic Operations:** For simple, single-variable updates, use `java.util.concurrent.atomic` classes (`AtomicInteger`, `AtomicReference`).
     \* **Thread-Safe Collections:** Use concurrent collections (e.g., `ConcurrentHashMap`, `CopyOnWriteArrayList`) when multiple threads need to access collections.
     \* **Message Passing:** Instead of direct shared memory, use `Handler`s, `Message`s, or `Channels` (Coroutines) to pass data between threads, ensuring operations on data are done on a single, dedicated thread.
     \* **`ViewModel` and `LiveData`/`StateFlow`:** In Android, `ViewModel`s are designed to hold UI-related data and expose it via `LiveData` or `StateFlow`, which are designed to be thread-safe for observing changes on the main thread.

141. **What is the relationship between AsyncTask and Activity problems?**
     `AsyncTask` was an older, simplified helper class for performing short background operations and publishing results to the UI thread. However, it had a problematic relationship with Activity lifecycles, leading to common issues:
     \* **Memory Leaks:** `AsyncTask` holds an implicit reference to the `Activity` (if it's an inner non-static class). If the `Activity` is destroyed (e.g., screen rotation) before the `AsyncTask` completes, the `Activity` cannot be garbage collected, leading to a memory leak.
     \* **Lost Callbacks:** If the `Activity` is recreated, the `AsyncTask` might complete and try to update the *old*, non-existent `Activity` instance, or simply not be able to find the new `Activity` instance to update its UI.
     \* **Configuration Changes:** `AsyncTask` doesn't inherently handle configuration changes well, requiring manual management or leading to the above issues.
     Due to these problems and the availability of better solutions, `AsyncTask` has been deprecated since API 30. **Kotlin Coroutines with `ViewModel` and `WorkManager` are the modern, recommended alternatives.**

## Networking & Web Services

142. **How do Android apps make network requests?**
     Android apps make network requests using various libraries and APIs, almost always performing these operations on a background thread to avoid ANRs.
     Common ways:
     \* **`HttpURLConnection` (Built-in):** The native Java API for making HTTP requests. It's available on all Android versions but is lower-level and requires more boilerplate code.
     \* **`OkHttp` (Recommended):** A modern, efficient, and robust HTTP client library. It handles connection pooling, gzipping, caching, and retries automatically. Many higher-level libraries (like Retrofit) use OkHttp internally.
     \* **`Retrofit` (Recommended):** A type-safe HTTP client for Android and Java. It simplifies making REST API calls by turning HTTP API into a Java interface. It works on top of OkHttp.
     \* **`Volley` (Older, for simpler cases):** A library from Google for fast networking operations, especially for small requests and image loading. Less flexible for complex APIs than Retrofit.
     \* **WorkManager:** Can be used to schedule and execute network requests reliably in the background, even if the app closes.
     \* **Kotlin Coroutines:** Used in conjunction with networking libraries (like Retrofit) to perform asynchronous network calls in a clean, sequential manner.

143. **What is Retrofit and why is it popular?**
     `Retrofit` is a type-safe HTTP client library developed by Square for Android and Java. It simplifies the process of making network requests to RESTful APIs by turning HTTP API calls into declarative interface methods.
     **Why it's popular:**
     \* **Type Safety:** You define your API as an interface with annotated methods, reducing common errors.
     \* **Less Boilerplate:** Automatically handles URL construction, request body serialization (JSON/XML), response parsing, and error handling.
     \* **Easy Integration:** Seamlessly integrates with various JSON/XML parsing libraries (Gson, Moshi) and asynchronous programming models (Kotlin Coroutines, RxJava).
     \* **Built on OkHttp:** Leverages OkHttp's efficiency for underlying network operations.
     \* **Interceptors:** Allows adding custom logic for request/response modification (e.g., authentication tokens, logging).
     \* **Flexibility:** Supports various HTTP methods, custom headers, query parameters, and multipart requests.

144. **What is OkHttp and its role in networking?**
     `OkHttp` is an efficient, modern HTTP client for Java and Kotlin, also developed by Square. It's a low-level networking library that handles the actual HTTP requests and responses.
     **Its role in networking:**
     \* **Underlying Engine:** It serves as the HTTP engine for many higher-level libraries (like Retrofit and Glide).
     \* **Performance Optimization:** Handles features like connection pooling (reusing sockets), GZIP compression, response caching, and automatic retries for transient connection problems, leading to faster and more efficient network operations.
     \* **Network Resilience:** Automatically recovers from common connection problems.
     \* **Modern HTTP Features:** Supports HTTP/2, WebSockets.
     \* **Interceptors:** Provides a powerful mechanism to intercept and modify requests and responses (e.g., for logging, adding headers, authentication).

145. **What are RESTful APIs and HTTP methods?**
     \* **RESTful APIs (Representational State Transfer):** A software architectural style for designing networked applications. It's an approach to communications between client and server that leverages standard HTTP protocols. RESTful APIs are stateless, client-server based, and utilize a uniform interface to interact with resources identified by URIs.
     \* **HTTP Methods (Verbs):** Standard verbs used in RESTful APIs to indicate the desired action to be performed on a resource.

       * **`GET`:** Retrieves a resource or a collection of resources (read-only).
       * **`POST`:** Creates a new resource or sends data to be processed.
       * **`PUT`:** Updates an existing resource (replaces the entire resource).
       * **`PATCH`:** Partially updates an existing resource (applies a partial modification).
       * **`DELETE`:** Removes a resource.
       * **`HEAD`:** Similar to GET, but retrieves only the response headers, not the body.
       * **`OPTIONS`:** Describes the communication options for the target resource.

146. **What is JSON and why is it used for data exchange?**
     JSON (JavaScript Object Notation) is a lightweight, human-readable, and machine-parsable data-interchange format. It is based on a subset of the JavaScript Programming Language Standard ECMA-262 3rd Edition - December 1999.
     **Why it's used for data exchange:**
     \* **Readability:** Easy for humans to read and write.
     \* **Simplicity:** Simple data structures (key-value pairs, ordered lists).
     \* **Parsability:** Easy for machines to parse and generate.
     \* **Language Independent:** Supported by almost all programming languages, making it ideal for cross-platform communication between clients and servers.
     \* **Lightweight:** Compared to XML, it has less overhead, resulting in smaller file sizes and faster parsing.
     It has become the de facto standard for data exchange in web and mobile applications communicating with RESTful APIs.

147. **How do you handle network errors and retries?**
     Handling network errors and implementing retries are crucial for robust network requests.
     **Handling Errors:**
     \* **Try-Catch Blocks:** For basic error handling (e.g., `IOException` for connectivity issues, `HttpException` for HTTP error codes in Coroutines/Retrofit).
     \* **Sealed Classes/Result Wrappers:** Define sealed classes or wrapper classes to represent different states of a network request (Success, Error, Loading) to explicitly handle various error scenarios (network unavailable, server error, parsing error).
     \* **Retrofit ErrorBody:** Parse the `errorBody()` from a `Response` object in Retrofit to get detailed error messages from the server (e.g., JSON error responses).
     \* **Global Error Handlers/Interceptors:** Use OkHttp interceptors to log errors or show generic error messages for all network requests.
     **Retries:**
     \* **OkHttp Interceptors:** Implement a custom `Interceptor` in OkHttp to retry requests for specific error codes or connectivity issues.
     \* **Retrofit + Coroutines:** Use `retryWhen` or `retry` operators with `Flow` or implement custom retry logic with `delay()` in your `suspend` functions.
     \* **WorkManager:** Built-in retry mechanisms with exponential backoff for failed work requests.

148. **What is a Multipart request and when is it used?**
     A `Multipart` request is an HTTP request format designed to send multiple distinct parts of data within a single request body. Each part can have its own content type and headers.
     **When it is used:**
     \* **File Uploads:** The most common use case. When you need to upload one or more files (e.g., images, documents, videos) along with other form data (e.g., text fields) in a single HTTP POST request.
     \* **Complex Forms:** For forms that contain a mixture of text, binary data, and multiple fields that need to be sent together.
     Libraries like Retrofit (with OkHttp) provide easy ways to construct and send multipart requests using `@Part` annotations.

149. **How do you upload files using Retrofit?**
     To upload files using Retrofit, you typically use `Multipart` requests.
     1\.  **Define API Interface:**

     ```kotlin
     interface MyApiService {
         @Multipart
         @POST("upload")
         suspend fun uploadFile(
             @Part file: MultipartBody.Part,
             @Part("description") description: RequestBody // For text parts
         ): Response<ResponseBody> // Or your data class for the response
     }
     ```

<!-- end list -->

````
2.  **Prepare `MultipartBody.Part`:**
    ```kotlin
    // Create RequestBody for file
    val file = File(filePath) // Your actual file path
    val requestFile = file.asRequestBody("image/jpeg".toMediaTypeOrNull()) // Or other media type
    val filePart = MultipartBody.Part.createFormData("image", file.name, requestFile) // "image" is the server-expected field name

    // Create RequestBody for description
    val description = "My image description".toRequestBody("text/plain".toMediaTypeOrNull())
    ```
3.  **Make the Call:**
    ```kotlin
    val response = myApiService.uploadFile(filePart, description)
    // Handle response
    ```
````

150. **What is Gson and its purpose in JSON parsing?**
     `Gson` (Google Gson) is a Java library that can be used to convert Java objects into their JSON representation and vice versa. It's a popular choice for JSON serialization and deserialization in Android applications.
     **Its purpose in JSON parsing:**
     \* **Serialization:** Converting Java/Kotlin objects (POJOs/data classes) into JSON strings (e.g., when sending data to a server).
     \* **Deserialization:** Converting JSON strings received from an API into Java/Kotlin objects (e.g., when parsing a server response into your data models).
     \* **Automatic Mapping:** It automatically maps JSON fields to corresponding object fields based on names, making it very convenient. You can also use annotations (`@SerializedName`) for custom mapping.
     Retrofit integrates seamlessly with Gson using a `GsonConverterFactory`.

151. **What is Volley Library in Android?**
     `Volley` is an HTTP library developed by Google that helps Android apps manage network requests efficiently. It's designed for fast, simple networking, especially for applications that make many small requests and for image loading.
     **Key features:**
     \* **Automatic Request Queueing:** Manages a queue of network requests.
     \* **Caching:** Built-in support for disk and memory caching of responses.
     \* **Prioritization:** Allows setting priorities for requests.
     \* **Cancellation:** Easy cancellation of individual or grouped requests.
     \* **Image Loading:** Strong support for loading and caching images efficiently.
     Compared to Retrofit/OkHttp, Volley is often seen as more suitable for simpler, fire-and-forget requests, while Retrofit offers more power and type safety for complex REST APIs.

152. **Compare HTTP Long-Polling vs WebSockets vs Server-Sent Events.**
     These are techniques for enabling real-time or near real-time communication between a client and a server over HTTP:
     \* **HTTP Long-Polling:**

       * **How it works:** The client makes a regular HTTP request, but the server holds the connection open until new data is available or a timeout occurs. Once data is sent (or timeout), the connection closes, and the client immediately opens a new request.
       * **Pros:** Works with standard HTTP, no special server setup needed beyond typical web server.
       * **Cons:** Not truly real-time (latency due to new connection for each update), more overhead per message, difficult to send data from client to server (requires a separate request).
       * **Use Case:** Infrequent updates, low-to-medium real-time needs (e.g., simple chat, notification systems).
         \* **WebSockets:**
       * **How it works:** After an initial HTTP handshake, a persistent, bi-directional, full-duplex communication channel is established over a single TCP connection.
       * **Pros:** Truly real-time, low latency, efficient (minimal overhead after handshake), bi-directional (client and server can send messages anytime).
       * **Cons:** Requires a dedicated WebSocket server, not compatible with all proxies/firewalls.
       * **Use Case:** High-frequency, bi-directional real-time applications (e.g., live chat, gaming, real-time dashboards).
         \* **Server-Sent Events (SSE):**
       * **How it works:** The client establishes a single, long-lived HTTP connection to the server. The server can then push data to the client over this connection whenever new data is available. It's a unidirectional (server-to-client) stream.
       * **Pros:** Simpler than WebSockets (uses standard HTTP), automatically reconnects on network issues, built-in event stream format.
       * **Cons:** Unidirectional (client-to-server requires separate HTTP requests), limited to text data by default.
       * **Use Case:** Unidirectional real-time updates where the server pushes data frequently (e.g., stock tickers, live sports scores, news feeds).

153. **How would you debug server errors in POST requests?**
     Debugging server errors in POST requests involves examining both the client-side request and the server-side response:
     1\.  **Check Client-Side Request:**

       * **Verify URL and Endpoint:** Is the POST request going to the correct API endpoint?
       * **Inspect Request Body:** Is the JSON/form data being sent correctly formatted and containing all required fields? Use a logging `Interceptor` with OkHttp to print the full request body.
       * **Check Headers:** Are necessary headers (e.g., `Content-Type`, `Authorization` tokens) being sent?
         2\.  **Examine Server Response:**
       * **HTTP Status Code:** Is it a 4xx (client error) or 5xx (server error) code? The code provides a high-level clue.
       * **Response Body:** The most crucial part. The server will often return an error message, validation failures, or stack traces in the response body (often in JSON format). Log the full `response.errorBody().string()` from Retrofit.
       * **Server Logs:** Access the server-side logs. These will often show more detailed error messages, exceptions, or database errors.
         3\.  **Tools:**
       * **OkHttp Logging Interceptor:** In development, add an `HttpLoggingInterceptor` to your OkHttp client to log all request and response details.
       * **Charles Proxy/Fiddler/Proxyman:** Use a network proxy tool to intercept and inspect HTTP/HTTPS traffic between your app and the server. This gives you a clear view of exactly what's being sent and received.
       * **Postman/Insomnia:** Replicate the POST request using a dedicated API client to isolate if the issue is client-specific or a general API problem.

154. **What are security considerations for network requests?**
     Securing network requests is vital for protecting user data and app integrity:
     \* **HTTPS/TLS:** Always use HTTPS (TLS) for all network communication to encrypt data in transit, preventing eavesdropping and tampering. Never use plain HTTP for sensitive data.
     \* **Certificate Pinning:** For highly sensitive applications, implement Certificate Pinning. This validates the server's certificate against a known, pre-specified certificate or public key within the app, preventing Man-in-the-Middle (MITM) attacks.
     \* **Data Validation:** Validate all data received from the server on the client side to prevent malformed or malicious data from causing crashes or vulnerabilities.
     \* **Authentication/Authorization:** Implement secure authentication mechanisms (e.g., OAuth2, JWT) and ensure proper authorization checks on the server side. Store authentication tokens securely (e.g., `EncryptedSharedPreferences`).
     \* **No Hardcoded Secrets:** Never hardcode API keys, secrets, or sensitive credentials directly into the app's code. Retrieve them securely from a backend or use build configuration for non-sensitive values.
     \* **Input Sanitization:** Sanitize all user input before sending it to the server to prevent injection attacks.
     \* **Error Handling:** Implement robust error handling to avoid exposing sensitive information in error messages.
     \* **Obfuscation/Minification (R8):** Use R8 to obfuscate your code, making reverse engineering more difficult (though not impossible).

155. **What are benefits of network caching strategies?**
     Network caching strategies involve storing responses from network requests locally on the device so that they can be served without re-fetching from the network.
     **Benefits:**
     \* **Improved Performance/Responsiveness:** Reduces latency by serving content immediately from cache, making the app feel faster and more responsive.
     \* **Reduced Network Usage:** Minimizes data consumption, which saves battery life and reduces user data costs.
     \* **Offline Support:** Enables the app to display content even when there is no network connectivity, providing a better user experience (offline-first).
     \* **Reduced Server Load:** Less frequent requests to the backend reduce the load on your servers.
     \* **Better User Experience:** Provides a seamless experience, especially in areas with spotty network coverage.
     Caching can be implemented using HTTP caching headers, OkHttp's built-in cache, or by storing data in databases (like Room).

156. **How do you implement offline-first architecture?**
     An offline-first architecture designs an application to function fully or partially even when there's no network connectivity. It prioritizes local data storage and synchronization.
     **Implementation involves:**
     \* **Local Data Store (Source of Truth):** Use a robust local database (like Room) as the primary source of truth for all application data. All UI interactions and data reads happen from this local database.
     \* **Synchronization Layer:** Implement a synchronization mechanism (e.g., using WorkManager for one-time or periodic sync, or WebSockets for real-time sync) to:

       * Fetch new data from the network and store it in the local database.
       * Push local changes (user-generated data) to the server.
       * Handle conflicts during synchronization.
         \* **Network Awareness:** Use `ConnectivityManager` to monitor network availability and trigger sync operations when online.
         \* **Optimistic UI:** Update the UI immediately based on local changes, assuming the server operation will succeed, and handle potential failures gracefully.
         \* **`LiveData`/`Flow` from Database:** Connect your UI components to observe data changes from the local database, ensuring the UI always reflects the current local state.

157. **What is Certificate Pinning and why is it important?**
     Certificate pinning (also known as SSL pinning or Public Key Pinning) is a security mechanism used to prevent Man-in-the-Middle (MITM) attacks. It's an enhancement to the standard HTTPS/TLS security.
     **How it works:** Instead of relying on the system's trust store for Certificate Authorities, the application explicitly "pins" (stores) the expected server certificate (or its public key) directly within its code. When the app makes an HTTPS connection, it validates the server's certificate not only against the CA but also against the pinned certificate/key. If they don't match, the connection is aborted, even if the certificate is issued by a trusted CA.
     **Why it's important:**
     \* **Prevents MITM Attacks:** If a malicious actor compromises a Certificate Authority or tricks a user into installing a rogue CA certificate, pinning prevents them from issuing fake certificates for your domain and intercepting traffic.
     \* **Enhanced Security:** Adds an extra layer of security, especially crucial for apps handling highly sensitive data (e.g., banking, healthcare).
     \* **Detects Compromise:** Can help detect if a network or server has been compromised.
     It adds complexity to maintenance (pins need updating when certificates change) but provides a significant security boost.

## Architecture Patterns & Design

158. **What is Android Jetpack and its key benefits?**
     Android Jetpack is a suite of libraries, tools, and architectural guidance to help developers build high-quality, robust, and testable Android applications more easily. It's designed to accelerate development, eliminate boilerplate code, and allow developers to focus on what matters most.
     **Key Benefits:**
     \* **Accelerated Development:** Provides ready-to-use components and best practices.
     \* **Reduced Boilerplate:** Many components automate common tasks (e.g., `ViewModel`, `LiveData`, `Room`).
     \* **Consistency & Best Practices:** Encourages modern architecture patterns and helps developers write maintainable code.
     \* **Backward Compatibility:** Most Jetpack libraries are backward compatible, allowing you to use new features on older Android versions.
     \* **Lifecycle Awareness:** Components like `LiveData` and `ViewModel` are lifecycle-aware, reducing memory leaks and simplifying state management.
     \* **Robustness:** Designed for reliability and testability.

159. **What are Android Architecture Components?**
     Android Architecture Components are a collection of libraries within Android Jetpack that help developers design robust, testable, and maintainable applications by providing solutions for common architectural problems, especially around UI data management and lifecycle awareness.
     Key Architecture Components include:
     \* **`ViewModel`:** Stores and manages UI-related data in a lifecycle-conscious way.
     \* **`LiveData`:** An observable data holder that is lifecycle-aware.
     \* **`Room`:** An SQLite object mapping library for persistent data storage.
     \* **`Lifecycle`:** Classes that manage Activity/Fragment lifecycle events.
     \* **`Navigation`:** A framework for navigating between destinations within an app.
     \* **`Paging`:** For loading and displaying large datasets efficiently.
     \* **`WorkManager`:** For deferrable, guaranteed background work.
     \* **`DataStore`:** A modern replacement for `SharedPreferences`.

160. **What is MVVM architecture and how does it work?**
     MVVM (Model-View-ViewModel) is an architectural pattern for UI development that separates the UI (View) from the business logic and data (Model) using an intermediary called the ViewModel.
     **How it works:**
     \* **Model:** Represents the data and business logic of the application. It's responsible for fetching data, storing it, and providing methods to manipulate it. It's independent of the UI.
     \* **View:** The UI layer (Activity, Fragment, custom View). It's responsible for displaying the data from the ViewModel and sending user events (clicks, input) to the ViewModel. The View observes changes in the ViewModel.
     \* **ViewModel:** Acts as an intermediary between the Model and the View. It holds UI-related state and logic, prepares data from the Model for the View, and exposes this data via observable mechanisms (like `LiveData` or `StateFlow`). It receives user input from the View and passes it to the Model or handles it itself. The ViewModel is lifecycle-aware, surviving configuration changes.
     **Data Flow:** View (user action) -\> ViewModel -\> Model (data/logic) -\> ViewModel (prepared data) -\> View (observes data).

161. **Compare MVC vs MVP vs MVVM vs MVI architectures.**
     These are common architectural patterns, each addressing separation of concerns:

<!-- end list -->

```
* **MVC (Model-View-Controller):**
    * **Model:** Data logic.
    * **View:** UI (passive).
    * **Controller:** Handles user input, interacts with Model, and updates View.
    * **Pros:** Traditional, widely understood.
    * **Cons:** Controller can become a "Massive Controller" (God object), tight coupling between View and Controller, often hard to test View.

* **MVP (Model-View-Presenter):**
    * **Model:** Data logic.
    * **View:** UI (passive interface, e.g., an Activity implements `IView`).
    * **Presenter:** Handles UI logic, interacts with Model, updates View through its interface. Has a one-to-one relationship with the View.
    * **Pros:** Better separation of concerns than MVC, View is easily testable (mockable interface), Presenter is pure Java/Kotlin and easily testable.
    * **Cons:** Presenter can still become large, tight coupling between View and Presenter interfaces, potential boilerplate for interfaces.

* **MVVM (Model-View-ViewModel):**
    * **Model:** Data logic.
    * **View:** UI (active, observes ViewModel).
    * **ViewModel:** Exposes data from Model to View via observable streams (`LiveData`, `StateFlow`), handles UI logic, receives user events. No direct reference to View.
    * **Pros:** Excellent separation, ViewModel is lifecycle-aware (Android Architecture Components), View is easily testable (mock ViewModel), less boilerplate than MVP due to data binding.
    * **Cons:** Debugging data flow can be harder with complex data bindings, sometimes hard to know where to put specific logic.

* **MVI (Model-View-Intent):**
    * **Model:** Represents the *entire state* of the application (immutable state).
    * **View:** Displays the current state from the Model, sends user actions (Intents) to the Intent processor.
    * **Intent:** A user action or event.
    * **Reducer/Processor:** Receives Intents, processes them (often with side effects like network calls), and produces new states.
    * **Pros:** Unidirectional data flow (single source of truth), explicit state management, excellent for debugging (time-travel debugging), highly testable.
    * **Cons:** Can have more boilerplate for simple screens, handling complex state can be verbose, learning curve.
```

162. **What is Clean Architecture and its importance?**
     Clean Architecture, popularized by Robert C. Martin (Uncle Bob), is an architectural philosophy that advocates for a strict separation of concerns into concentric layers, aiming to create systems that are independent of frameworks, databases, and UI.
     **Layers (from innermost to outermost):**
     1\.  **Entities:** Core business rules (pure objects, no framework dependencies).
     2\.  **Use Cases (Interactors):** Application-specific business rules, orchestrate entities, independent of UI/DB.
     3\.  **Interface Adapters:** Convert data between Use Cases and external layers (e.g., Presenters, Gateways, DAOs).
     4\.  **Frameworks & Devices:** UI (Activities, Fragments), Databases (Room), Web (Retrofit), etc.
     **Importance:**
     \* **Independence:** Independent of UI, database, frameworks, external agencies. This makes components highly portable.
     \* **Testability:** Core business logic (Entities, Use Cases) can be tested easily without needing Android framework or database.
     \* **Maintainability:** Changes in one layer don't necessarily affect others.
     \* **Flexibility:** Easier to swap out external dependencies (e.g., change from SQLite to Realm, or Retrofit to Ktor).
     \* **Scalability:** Well-suited for large, complex applications that need to evolve over time.

163. **What is MVI architecture and its core concepts?**
     MVI (Model-View-Intent) is a reactive and unidirectional data flow architectural pattern that emphasizes a single source of truth for the application state.
     **Core Concepts:**
     \* **Intent:** Represents a user action or an event from the UI (e.g., "Click button," "Load data"). These are the only inputs to the system.
     \* **Model (State):** Represents the *entire, immutable state* of the application or a specific screen at any given time. It's a single, immutable data class that holds all the necessary information for the UI to render.
     \* **View:** A passive component responsible for rendering the current `Model` (state) and emitting `Intent`s based on user interactions.
     \* **Processor/Reducer (or State Manager):** Receives the `Intent`s, processes them (which might involve fetching data, performing calculations, or handling side effects), and then creates a *new* `Model` (state) based on the old state and the processed intent. This new state is then passed to the View.
     \* **Unidirectional Data Flow:** Data flows in one direction: View -\> Intent -\> Processor -\> New State -\> View. This makes state changes predictable and debugging easier.

164. **When might MVI be better than MVVM?**
     MVI might be better than MVVM in scenarios where:
     \* **Strict Unidirectional Data Flow is Critical:** If you need absolute certainty about how state changes and why, MVI's explicit, single-flow model is superior.
     \* **Complex UI State Management:** For screens with very intricate UI states and interactions where it's hard to track state changes with MVVM's potentially multiple `LiveData`s. MVI's single immutable state object simplifies this.
     \* **Time-Travel Debugging:** MVI's immutable state and explicit intent processing make it easier to implement "time-travel" debugging (replaying actions to see state changes).
     \* **Event Handling:** MVI makes the distinction between "state" (what to render) and "events" (one-time actions like showing a Toast) clearer.
     \* **Collaboration/Consistency:** For large teams, the strict patterns of MVI can enforce greater consistency and reduce ambiguity.
     For simpler screens, MVVM can still be more concise and quicker to implement.

165. **Explain unidirectional data flow concept.**
     Unidirectional data flow is an architectural principle where data moves in a single, predictable direction throughout the application. It's a core concept in patterns like MVI and Flux/Redux.
     **Key characteristics:**
     \* **Single Source of Truth:** The application state (or UI state) is held in one definitive place.
     \* **Actions/Intents as Input:** User interactions or external events are transformed into "actions" or "intents."
     \* **Processor/Reducer:** These actions are then processed by a central component (e.g., a reducer or state processor), which takes the current state and the action, and then calculates a *new* state. The old state is never directly modified.
     \* **State Updates to View:** The new state is then propagated to the UI (View), which re-renders itself based on this new state.
     **Benefits:**
     \* **Predictability:** State changes are easy to trace and understand, leading to fewer bugs.
     \* **Testability:** Each step in the data flow can be tested independently.
     \* **Debuggability:** Easier to debug as you can track every state transition.
     \* **Maintainability:** Consistent patterns make the codebase easier to maintain as it grows.

166. **What is the Repository pattern and its role?**
     The Repository pattern is an architectural pattern that abstracts the way data is retrieved and stored from the actual data sources. It acts as an intermediary layer between the domain/business logic (e.g., Use Cases, ViewModels) and the various data sources (e.g., local database, network API, SharedPreferences, cache).
     **Its role:**
     \* **Data Abstraction:** The `ViewModel` or Use Case interacts only with the `Repository` interface, not directly with the underlying data source implementations.
     \* **Single Source of Truth:** A `Repository` can decide whether to fetch data from the network, local database, or cache, providing a consistent "single source of truth" for data.
     \* **Separation of Concerns:** Decouples the business logic from data fetching/storage details, making each layer more focused and testable.
     \* **Offline Support:** Facilitates implementing offline-first strategies by managing data caching and synchronization.
     \* **Testability:** Allows mocking the `Repository` interface for unit testing `ViewModel`s or Use Cases without needing actual network or database calls.

167. **What is the role of Use Cases in Clean Architecture?**
     In Clean Architecture (and often in MVVM with a Repository), Use Cases (also called Interactors) represent the application-specific business rules or specific operations your application can perform. They bridge the gap between the higher-level (UI, ViewModel) and lower-level (Repository, data sources) layers.
     **Their role:**
     \* **Encapsulate Business Logic:** Each Use Case performs a single, specific business operation (e.g., `GetUserProfileUseCase`, `LoginUserUseCase`, `AddProductToCartUseCase`).
     \* **Orchestrate Data Flow:** They orchestrate the flow of data between the ViewModel/Presenter and the Repository. A Use Case might call one or more methods on a Repository to get data, apply business rules, and then return a result.
     \* **Independence:** They are pure Kotlin/Java classes, independent of Android framework dependencies, making them highly testable.
     \* **Reusability:** A Use Case can be reused by different ViewModels or Presenters if multiple screens require the same business logic.

168. **How do you handle separation of concerns?**
     Separation of concerns is a design principle that breaks down a complex system into distinct, independent sections, each responsible for a specific concern.
     In Android development, this is crucial for maintainability, testability, and scalability. It's handled by:
     \* **Architectural Patterns:** Employing patterns like MVVM, MVP, or Clean Architecture to define clear roles for different layers (e.g., View for UI, ViewModel/Presenter for UI logic, Model/Repository for data, Use Cases for business logic).
     \* **Modularization:** Breaking the app into separate modules (e.g., `:app`, `:feature:auth`, `:data`, `:domain`) where each module has a specific responsibility and limited dependencies.
     \* **Dependency Injection:** Using libraries like Hilt or Koin to inject dependencies (e.g., `Repository` into `ViewModel`), which loosens coupling between components.
     \* **Single Responsibility Principle (SRP):** Ensuring that each class or module has only one reason to change.
     \* **Encapsulation:** Hiding internal implementation details of a component and exposing only a well-defined public interface.
     \* **Lifecycle Awareness:** Using Android Architecture Components (`ViewModel`, `LiveData`) to manage UI state separately from `Activity`/`Fragment` lifecycle.

169. **What is Hexagonal Architecture?**
     Hexagonal Architecture (also known as Ports and Adapters architecture) is an architectural pattern that focuses on creating loosely coupled application components that are easily interchangeable. It aims to isolate the core business logic (the "domain" or "application" layer) from external concerns like the UI, databases, and third-party services.
     **Core Idea:** The core business logic resides in the center "hexagon." It communicates with the outside world through well-defined "ports." "Adapters" then connect these ports to specific external technologies.
     \* **Ports:** Interfaces that define how the core logic interacts with external systems (e.g., `UserRepository` interface).
     \* **Adapters:** Implementations of the ports that connect to concrete technologies (e.g., `RoomUserRepository` implementation, `RetrofitApiAdapter`).
     **Benefits:**
     \* **High Testability:** The core business logic is completely isolated and can be unit tested without requiring a database, UI, or network.
     \* **Technology Agnostic:** Easily swap out databases, UI frameworks, or third-party services without affecting the core logic.
     \* **Maintainability:** Clear boundaries and interfaces make the system easier to understand and evolve.
     Clean Architecture in Android often shares many principles with Hexagonal Architecture.

170. **How do you implement the Observer pattern in Android?**
     The Observer pattern is a software design pattern where an object (the "subject" or "observable") maintains a list of its dependents (the "observers") and notifies them automatically of any state changes, usually by calling one of their methods.
     In Android, it's commonly implemented using:
     \* **`LiveData` (Recommended):** The primary mechanism from Android Jetpack. `LiveData` is an observable data holder that is lifecycle-aware.

       * **Subject:** A `MutableLiveData` object in a `ViewModel`.
       * **Observer:** An `Activity` or `Fragment` calls `observe()` on the `LiveData` to receive updates.
       * **Benefits:** Automatically manages subscriptions based on lifecycle, preventing memory leaks.

     <!-- end list -->

     ```kotlin
     // ViewModel
     val myData: MutableLiveData<String> = MutableLiveData()
     fun updateData(newData: String) { myData.value = newData }

     // Activity/Fragment
     viewModel.myData.observe(viewLifecycleOwner) { data ->
         textView.text = data
     }
     ```

<!-- end list -->

````
* **Kotlin `Flow` (Recommended with Coroutines):** For reactive streams and more advanced asynchronous data handling.
    * **Subject:** A `StateFlow` or `SharedFlow` in a `ViewModel`.
    * **Observer:** The `Activity`/`Fragment` collects values from the `Flow` within a coroutine.
    ```kotlin
    // ViewModel
    private val _myData = MutableStateFlow("Initial")
    val myData: StateFlow<String> = _myData.asStateFlow()
    fun updateData(newData: String) { _myData.value = newData }

    // Activity/Fragment
    lifecycleScope.launch {
        viewModel.myData.collect { data ->
            textView.text = data
        }
    }
    ```
* **RxJava/RxKotlin (Third-party):** A powerful reactive programming library, offering `Observable`, `Flowable`, `Subject` types for creating observable streams.
* **Custom Interfaces/Listeners:** Define a listener interface in your subject, and implementing classes register themselves as listeners. The subject then calls the listener methods on state changes. This is more manual but foundational.
````
